---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ultra-High GDS Discovery — Theory of Anticipation</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: #080a12;
  color: #e0e0e0;
  min-height: 100vh;
}
.header {
  text-align: center;
  padding: 1.5rem 1rem 0.8rem;
  border-bottom: 1px solid #1a1d2a;
}
.header h1 { font-size: 1.4rem; color: #fff; letter-spacing: -0.02em; }
.header p { color: #666; font-size: 0.82rem; margin-top: 0.3rem; }
.main { max-width: 900px; margin: 0 auto; padding: 1rem; }

/* Controls */
.controls {
  display: flex; gap: 1rem; align-items: center;
  justify-content: center; flex-wrap: wrap;
  padding: 1rem; background: #0d0f1a; border-radius: 8px;
  margin-bottom: 1rem; border: 1px solid #1a1d2a;
}
.control-group { display: flex; flex-direction: column; align-items: center; gap: 0.3rem; }
.control-group label { font-size: 0.75rem; color: #666; text-transform: uppercase; letter-spacing: 0.05em; }
.control-group input[type=range] { width: 120px; accent-color: #5a7aef; }
.control-group .value { font-size: 1.1rem; color: #7a9aff; font-weight: 600; }
.btn {
  padding: 0.5rem 1.2rem; border: 1px solid #5a7aef; border-radius: 6px;
  background: #12152a; color: #7a9aff; cursor: pointer; font-family: inherit;
  font-size: 0.85rem; transition: all 0.2s;
}
.btn:hover { background: #1a1f3a; }
.btn.active { background: #5a7aef; color: #fff; }
.btn:disabled { opacity: 0.4; cursor: not-allowed; }

/* GDS Display */
.gds-display {
  text-align: center; padding: 1.5rem;
  background: linear-gradient(135deg, #0d0f1a, #121530);
  border-radius: 10px; border: 1px solid #1a1d2a;
  margin-bottom: 1rem;
}
.gds-number {
  font-size: 3.5rem; font-weight: 700; letter-spacing: -0.03em;
  background: linear-gradient(135deg, #5a7aef, #a855f7);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  background-clip: text;
}
.gds-label { font-size: 0.8rem; color: #666; margin-top: 0.3rem; }
.gds-comparison { font-size: 0.75rem; color: #888; margin-top: 0.5rem; }
.gds-comparison span { color: #5a7aef; font-weight: 600; }

/* Anticipation bars */
.anticipation-bars {
  display: flex; gap: 0.5rem; justify-content: center;
  padding: 1rem; background: #0d0f1a; border-radius: 8px;
  border: 1px solid #1a1d2a; margin-bottom: 1rem;
}
.a-bar {
  display: flex; flex-direction: column; align-items: center; gap: 0.3rem;
  width: 60px;
}
.a-bar .bar-container {
  width: 30px; height: 120px; background: #151830; border-radius: 4px;
  position: relative; overflow: hidden;
}
.a-bar .bar-fill {
  position: absolute; bottom: 0; width: 100%; border-radius: 4px;
  transition: height 0.5s ease;
}
.a-bar .bar-label { font-size: 0.7rem; color: #666; }
.a-bar .bar-value { font-size: 0.75rem; color: #aaa; }

/* Arena */
.arena {
  position: relative; height: 300px;
  background: linear-gradient(180deg, #0a0c18, #0d1020);
  border-radius: 10px; border: 1px solid #1a1d2a;
  margin-bottom: 1rem; overflow: hidden;
}
.player {
  position: absolute; bottom: 40px; width: 120px; text-align: center;
}
.player.p1 { left: 15%; }
.player.p2 { right: 15%; }
.player .name { font-size: 0.8rem; color: #888; margin-bottom: 0.3rem; }
.hp-bar-bg {
  width: 100%; height: 14px; background: #1a1d2a; border-radius: 7px;
  overflow: hidden;
}
.hp-bar-fill {
  height: 100%; border-radius: 7px; transition: width 0.4s ease;
}
.p1 .hp-bar-fill { background: linear-gradient(90deg, #3b82f6, #60a5fa); }
.p2 .hp-bar-fill { background: linear-gradient(90deg, #ef4444, #f87171); }
.hp-text { font-size: 1.5rem; font-weight: 700; margin: 0.3rem 0; }
.p1 .hp-text { color: #60a5fa; }
.p2 .hp-text { color: #f87171; }

/* Event log */
.event-log {
  position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
  font-size: 1rem; font-weight: 600; color: #fff;
  text-shadow: 0 0 20px rgba(90, 122, 239, 0.5);
  opacity: 0; transition: opacity 0.3s;
  text-align: center;
}
.event-log.visible { opacity: 1; }

/* Floating damage */
.damage-float {
  position: absolute; font-weight: 700; font-size: 1.5rem;
  pointer-events: none; animation: floatUp 1s ease-out forwards;
}
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-60px); }
}

/* Turn counter */
.turn-counter {
  position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
  font-size: 0.75rem; color: #444;
}

/* Chart */
.chart-container {
  background: #0d0f1a; border-radius: 8px; border: 1px solid #1a1d2a;
  padding: 1rem; margin-bottom: 1rem;
}
.chart-container h3 { font-size: 0.85rem; color: #888; margin-bottom: 0.5rem; text-align: center; }
canvas { width: 100%; height: 200px; }

/* Speed */
.speed-controls { display: flex; gap: 0.5rem; justify-content: center; margin-top: 0.5rem; }
.speed-btn {
  padding: 0.3rem 0.6rem; font-size: 0.7rem;
  border: 1px solid #1e2132; border-radius: 4px;
  background: transparent; color: #666; cursor: pointer;
}
.speed-btn.active { border-color: #5a7aef; color: #7a9aff; }

/* Insight */
.insight {
  background: #0d0f1a; border-radius: 8px; border: 1px solid #1a1d2a;
  padding: 1rem; font-size: 0.82rem; color: #888; line-height: 1.6;
}
.insight strong { color: #7a9aff; }
.insight .formula { font-family: 'Courier New', monospace; color: #a855f7; }
</style>
</head>
<body>
<div class="header">
  <h1>Ultra-High GDS Discovery</h1>
  <p>Asymmetric combat structures produce GDS values far beyond any previously known game design</p>
</div>
<div class="main">

<div class="controls">
  <div class="control-group">
    <label>Max HP</label>
    <input type="range" id="hpSlider" min="3" max="24" value="10">
    <div class="value" id="hpValue">10</div>
  </div>
  <div class="control-group">
    <label>Nest Level</label>
    <input type="range" id="nestSlider" min="3" max="10" value="5">
    <div class="value" id="nestValue">5</div>
  </div>
  <button class="btn" id="startBtn">Start Battle</button>
  <button class="btn" id="autoBtn">Auto-Play</button>
</div>

<div class="gds-display">
  <div class="gds-number" id="gdsNumber">—</div>
  <div class="gds-label">Game Design Score (GDS)</div>
  <div class="gds-comparison" id="gdsComparison"></div>
</div>

<div class="anticipation-bars" id="aBars"></div>

<div class="arena" id="arena">
  <div class="event-log" id="eventLog"></div>
  <div class="player p1">
    <div class="name">Player 1</div>
    <div class="hp-text" id="p1Hp">10</div>
    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p1Bar" style="width:100%"></div></div>
  </div>
  <div class="player p2">
    <div class="name">Player 2</div>
    <div class="hp-text" id="p2Hp">10</div>
    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p2Bar" style="width:100%"></div></div>
  </div>
  <div class="turn-counter" id="turnCounter">Turn 0</div>
</div>

<div class="speed-controls">
  <button class="speed-btn" data-speed="200">Fast</button>
  <button class="speed-btn active" data-speed="600">Normal</button>
  <button class="speed-btn" data-speed="1200">Slow</button>
</div>

<canvas id="chart" height="200"></canvas>

<div class="insight">
  <strong>Key Discovery:</strong> Asymmetric combat — where each turn randomly hurts one player but not both —
  produces GDS values that grow superlinearly with game depth. At HP=20, GDS reaches <span class="formula">34.49</span>,
  which is <strong>63x</strong> higher than the standard HpGame (0.55). The mechanism: every state has high A₁
  (immediate uncertainty), and deeper games accumulate more higher-order anticipation (A₂, A₃, ...) as
  the variation of anticipation itself becomes a source of excitement. This is the <strong>Unbound Conjecture</strong>
  in its most extreme form — and it's playable.
</div>

</div>

<script>
// ========== ToA ENGINE (simplified for browser) ==========
function computeToA(maxHp, nestLevel) {
  const outcomes = [
    [0.25, 0, -1], [0.25, -1, 0],
    [0.14, 0, -2], [0.14, -2, 0],
    [0.06, 1, -2], [0.06, -2, 1],
    [0.05, 0, -maxHp], [0.05, -maxHp, 0],
  ];

  const stateKey = (h1, h2) => `${h1},${h2}`;
  const states = new Map();

  // Enumerate all reachable states
  const queue = [[maxHp, maxHp]];
  const visited = new Set();
  visited.add(stateKey(maxHp, maxHp));

  while (queue.length > 0) {
    const [h1, h2] = queue.shift();
    if (h1 <= 0 || h2 <= 0) {
      states.set(stateKey(h1, h2), { h1, h2, terminal: true, d: h1 > 0 && h2 <= 0 ? 1 : 0 });
      continue;
    }
    const transitions = [];
    for (const [p, d1, d2] of outcomes) {
      const n1 = Math.max(0, Math.min(maxHp, h1 + d1));
      const n2 = Math.max(0, Math.min(maxHp, h2 + d2));
      transitions.push([p, n1, n2]);
      const k = stateKey(n1, n2);
      if (!visited.has(k)) { visited.add(k); queue.push([n1, n2]); }
    }
    // Merge duplicate transitions
    const merged = new Map();
    for (const [p, n1, n2] of transitions) {
      const k = stateKey(n1, n2);
      merged.set(k, (merged.get(k) || 0) + p);
    }
    states.set(stateKey(h1, h2), {
      h1, h2, terminal: false,
      transitions: Array.from(merged.entries()).map(([k, p]) => [p, ...k.split(',').map(Number)]),
    });
  }

  // Compute D_global for all states (backward induction)
  const dGlobal = new Map();
  for (const [k, s] of states) {
    if (s.terminal) dGlobal.set(k, s.d);
  }

  // Iterative convergence
  for (let iter = 0; iter < 200; iter++) {
    let changed = false;
    for (const [k, s] of states) {
      if (s.terminal) continue;
      let d = 0;
      for (const [p, n1, n2] of s.transitions) {
        d += p * (dGlobal.get(stateKey(n1, n2)) || 0);
      }
      if (Math.abs(d - (dGlobal.get(k) || 0)) > 1e-12) changed = true;
      dGlobal.set(k, d);
    }
    if (!changed) break;
  }

  // Compute A_k up to nestLevel
  const aValues = new Map(); // stateKey -> [a1, a2, ...]
  for (const [k, s] of states) {
    aValues.set(k, new Array(nestLevel).fill(0));
  }

  // A_1 = E[|delta_D|] / 2
  for (const [k, s] of states) {
    if (s.terminal) continue;
    const d0 = dGlobal.get(k);
    let a1 = 0;
    for (const [p, n1, n2] of s.transitions) {
      a1 += p * Math.abs(dGlobal.get(stateKey(n1, n2)) - d0);
    }
    aValues.get(k)[0] = a1 / 2;
  }

  // A_k = E[|delta_A_{k-1}|] / 2
  for (let level = 1; level < nestLevel; level++) {
    for (const [k, s] of states) {
      if (s.terminal) continue;
      const a_prev = aValues.get(k)[level - 1];
      let ak = 0;
      for (const [p, n1, n2] of s.transitions) {
        const next_a = aValues.get(stateKey(n1, n2))[level - 1];
        ak += p * Math.abs(next_a - a_prev);
      }
      aValues.get(k)[level] = ak / 2;
    }
  }

  // GDS = weighted average of sum_a across non-terminal states
  let totalWeight = 0, weightedSum = 0;
  const gdsComponents = new Array(nestLevel).fill(0);
  let ntCount = 0;
  for (const [k, s] of states) {
    if (s.terminal) continue;
    ntCount++;
    const av = aValues.get(k);
    const reach = 1; // simplified: equal weight
    for (let i = 0; i < nestLevel; i++) {
      gdsComponents[i] += av[i];
    }
  }
  for (let i = 0; i < nestLevel; i++) gdsComponents[i] /= ntCount;
  const gds = gdsComponents.reduce((a, b) => a + b, 0);

  return { gds, components: gdsComponents, dGlobal, aValues, states };
}

// ========== GAME STATE ==========
let maxHp = 10, nestLevel = 5;
let hp1, hp2, turn, playing, autoPlay, speed = 600;
let toaData = null;
let gdsHistory = [];

const $ = id => document.getElementById(id);

// ========== UI UPDATES ==========
function updateGDS() {
  toaData = computeToA(maxHp, nestLevel);
  $('gdsNumber').textContent = toaData.gds.toFixed(4);

  const hpGameGDS = 0.4305;
  const rageGDS = 0.5507;
  const ratio = (toaData.gds / rageGDS).toFixed(1);
  $('gdsComparison').innerHTML =
    `<span>${ratio}x</span> HpGame_Rage (0.55) · <span>${(toaData.gds / hpGameGDS).toFixed(1)}x</span> HpGame (0.43)`;

  updateAnticipationBars();
}

function updateAnticipationBars() {
  const container = $('aBars');
  const colors = ['#3b82f6', '#8b5cf6', '#a855f7', '#d946ef', '#ec4899',
                  '#f43f5e', '#f97316', '#eab308', '#22c55e', '#06b6d4'];
  const k = stateKey(hp1 || maxHp, hp2 || maxHp);
  const av = toaData.aValues.get(k) || toaData.components;
  const maxA = Math.max(...av, 0.01);

  let html = '';
  for (let i = 0; i < nestLevel; i++) {
    const h = Math.max(2, (av[i] / maxA) * 100);
    html += `<div class="a-bar">
      <div class="bar-container"><div class="bar-fill" style="height:${h}%;background:${colors[i]}"></div></div>
      <div class="bar-label">A${i + 1}</div>
      <div class="bar-value">${av[i].toFixed(3)}</div>
    </div>`;
  }
  container.innerHTML = html;
}

function stateKey(h1, h2) { return `${h1},${h2}`; }

function updateArena() {
  $('p1Hp').textContent = hp1;
  $('p2Hp').textContent = hp2;
  $('p1Bar').style.width = `${(hp1 / maxHp) * 100}%`;
  $('p2Bar').style.width = `${(hp2 / maxHp) * 100}%`;
  $('turnCounter').textContent = `Turn ${turn}`;

  // Update A bars for current state
  if (toaData && hp1 > 0 && hp2 > 0) {
    const k = stateKey(hp1, hp2);
    const av = toaData.aValues.get(k);
    if (av) {
      const maxA = Math.max(...av, 0.01);
      const bars = document.querySelectorAll('.a-bar');
      bars.forEach((bar, i) => {
        if (i < av.length) {
          const fill = bar.querySelector('.bar-fill');
          const val = bar.querySelector('.bar-value');
          fill.style.height = `${Math.max(2, (av[i] / maxA) * 100)}%`;
          val.textContent = av[i].toFixed(3);
        }
      });
    }
  }

  // D_global display
  if (toaData && hp1 > 0 && hp2 > 0) {
    const d = toaData.dGlobal.get(stateKey(hp1, hp2));
    if (d !== undefined) {
      $('p1Hp').title = `Win prob: ${(d * 100).toFixed(1)}%`;
      $('p2Hp').title = `Win prob: ${((1 - d) * 100).toFixed(1)}%`;
    }
  }
}

function showEvent(text) {
  const el = $('eventLog');
  el.textContent = text;
  el.classList.add('visible');
  setTimeout(() => el.classList.remove('visible'), speed * 0.8);
}

function showDamage(player, amount) {
  const arena = $('arena');
  const el = document.createElement('div');
  el.className = 'damage-float';
  el.style.color = amount > 0 ? '#22c55e' : '#ef4444';
  el.textContent = amount > 0 ? `+${amount}` : `${amount}`;
  if (player === 1) {
    el.style.left = '20%';
  } else {
    el.style.right = '20%';
  }
  el.style.top = '40%';
  arena.appendChild(el);
  setTimeout(() => el.remove(), 1000);
}

// ========== GAME LOGIC ==========
const outcomes = () => [
  [0.25, 0, -1], [0.25, -1, 0],
  [0.14, 0, -2], [0.14, -2, 0],
  [0.06, 1, -2], [0.06, -2, 1],
  [0.05, 0, -maxHp], [0.05, -maxHp, 0],
];

function rollOutcome() {
  const oc = outcomes();
  let r = Math.random();
  for (const [p, d1, d2] of oc) {
    r -= p;
    if (r <= 0) return [d1, d2];
  }
  return oc[oc.length - 1].slice(1);
}

function doTurn() {
  if (hp1 <= 0 || hp2 <= 0) {
    playing = false;
    autoPlay = false;
    $('autoBtn').classList.remove('active');
    showEvent(hp1 > 0 ? 'Player 1 Wins!' : 'Player 2 Wins!');
    return;
  }

  turn++;
  const [d1, d2] = rollOutcome();
  const oldHp1 = hp1, oldHp2 = hp2;
  hp1 = Math.max(0, Math.min(maxHp, hp1 + d1));
  hp2 = Math.max(0, Math.min(maxHp, hp2 + d2));

  // Show what happened
  let desc = '';
  if (d1 < 0 && d2 === 0) { desc = `P1 takes ${-d1} damage`; showDamage(1, d1); }
  else if (d2 < 0 && d1 === 0) { desc = `P2 takes ${-d2} damage`; showDamage(2, d2); }
  else if (d1 > 0 && d2 < 0) { desc = `P1 heals ${d1}, P2 takes ${-d2}`; showDamage(1, d1); showDamage(2, d2); }
  else if (d2 > 0 && d1 < 0) { desc = `P2 heals ${d2}, P1 takes ${-d1}`; showDamage(2, d2); showDamage(1, d1); }
  else { desc = 'Nothing happens'; }

  if (d1 <= -maxHp || d2 <= -maxHp) desc = 'CRITICAL HIT! ' + desc;

  showEvent(desc);
  updateArena();

  // Record for chart
  const k = stateKey(hp1, hp2);
  const d = hp1 > 0 && hp2 > 0 ? (toaData.dGlobal.get(k) || 0.5) : (hp1 > 0 ? 1 : 0);
  gdsHistory.push({ turn, d, hp1, hp2 });
  drawChart();

  if (hp1 <= 0 || hp2 <= 0) {
    setTimeout(() => {
      playing = false;
      autoPlay = false;
      $('autoBtn').classList.remove('active');
      showEvent(hp1 > 0 ? 'Player 1 Wins!' : hp2 > 0 ? 'Player 2 Wins!' : 'Draw!');
    }, 200);
  }
}

function startGame() {
  hp1 = maxHp; hp2 = maxHp; turn = 0;
  playing = true; gdsHistory = [];
  gdsHistory.push({ turn: 0, d: 0.5, hp1: maxHp, hp2: maxHp });
  updateArena();
  updateAnticipationBars();
  drawChart();
}

// ========== CHART ==========
function drawChart() {
  const canvas = $('chart');
  const ctx = canvas.getContext('2d');
  const W = canvas.width = canvas.clientWidth * 2;
  const H = canvas.height = 400;
  ctx.clearRect(0, 0, W, H);

  if (gdsHistory.length < 2) return;

  const pad = { t: 30, r: 20, b: 30, l: 50 };
  const cw = W - pad.l - pad.r;
  const ch = H - pad.t - pad.b;

  // Draw grid
  ctx.strokeStyle = '#1a1d2a';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(pad.l, pad.t + ch / 2);
  ctx.lineTo(pad.l + cw, pad.t + ch / 2);
  ctx.stroke();

  // Label
  ctx.fillStyle = '#444';
  ctx.font = '20px sans-serif';
  ctx.fillText('1.0', pad.l - 35, pad.t + 6);
  ctx.fillText('0.5', pad.l - 35, pad.t + ch / 2 + 6);
  ctx.fillText('0.0', pad.l - 35, pad.t + ch + 6);
  ctx.fillText('P1 Win Probability', pad.l, pad.t - 10);

  // Line
  const maxTurn = Math.max(gdsHistory.length - 1, 1);
  ctx.beginPath();
  ctx.strokeStyle = '#5a7aef';
  ctx.lineWidth = 3;
  for (let i = 0; i < gdsHistory.length; i++) {
    const x = pad.l + (i / maxTurn) * cw;
    const y = pad.t + (1 - gdsHistory[i].d) * ch;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Current point
  if (gdsHistory.length > 0) {
    const last = gdsHistory[gdsHistory.length - 1];
    const x = pad.l + ((gdsHistory.length - 1) / maxTurn) * cw;
    const y = pad.t + (1 - last.d) * ch;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#5a7aef';
    ctx.fill();
  }
}

// ========== EVENT HANDLERS ==========
$('hpSlider').oninput = function() {
  maxHp = +this.value;
  $('hpValue').textContent = maxHp;
  updateGDS();
};

$('nestSlider').oninput = function() {
  nestLevel = +this.value;
  $('nestValue').textContent = nestLevel;
  updateGDS();
};

$('startBtn').onclick = () => {
  startGame();
  doTurn();
};

$('autoBtn').onclick = () => {
  if (!playing) startGame();
  autoPlay = !autoPlay;
  $('autoBtn').classList.toggle('active', autoPlay);
  if (autoPlay) autoStep();
};

function autoStep() {
  if (!autoPlay || !playing) return;
  doTurn();
  if (playing && autoPlay) setTimeout(autoStep, speed);
}

document.querySelectorAll('.speed-btn').forEach(btn => {
  btn.onclick = () => {
    speed = +btn.dataset.speed;
    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  };
});

// Click arena for manual step
$('arena').onclick = () => {
  if (playing && !autoPlay) doTurn();
};

// ========== INIT ==========
updateGDS();
startGame();
</script>
</body>
</html>
