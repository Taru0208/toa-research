---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ToA Calculator — Game Design Analysis</title>
<meta name="description" content="Analyze game tension, player agency, and fun alignment with real-time metrics. Test 5 game models including coin flips, HP combat, and tactical combat.">
<meta property="og:title" content="ToA Calculator — Game Design Analysis">
<meta property="og:description" content="Real-time game design analysis tool. Compute GDS, policy impact, and fun alignment across 5 game models.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://taru0208.github.io/toa-research/calculator/">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ToA Calculator — Game Design Analysis">
<meta name="twitter:description" content="Real-time game design analysis tool. Compute tension, agency, and fun alignment across 5 game models.">
<link rel="canonical" href="https://taru0208.github.io/toa-research/calculator/">
<style>
:root {
  --bg: #0d1117; --surface: #161b22; --surface2: #21262d;
  --border: #30363d; --text: #e6edf3; --text2: #8b949e;
  --accent: #58a6ff; --green: #3fb950; --orange: #d29922; --red: #f85149;
  --purple: #bc8cff;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif; font-size: 14px; line-height: 1.5; }
.container { max-width: 1200px; margin: 0 auto; padding: 20px; }
h1 { font-size: 24px; font-weight: 600; margin-bottom: 4px; }
.subtitle { color: var(--text2); margin-bottom: 24px; }
.grid { display: grid; grid-template-columns: 340px 1fr; gap: 20px; }
@media (max-width: 800px) { .grid { grid-template-columns: 1fr; } }

/* Panels */
.panel { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 16px; }
.panel-title { font-size: 13px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text2); margin-bottom: 12px; }

/* Controls */
.control-group { margin-bottom: 14px; }
.control-label { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 4px; }
.control-label span:last-child { color: var(--accent); font-weight: 600; font-family: monospace; }
input[type="range"] { width: 100%; height: 6px; -webkit-appearance: none; background: var(--surface2); border-radius: 3px; outline: none; }
input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent); cursor: pointer; }
select { width: 100%; padding: 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 13px; }

/* Metrics */
.metrics-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-bottom: 16px; }
.metric-card { background: var(--surface2); border-radius: 6px; padding: 10px; text-align: center; }
.metric-value { font-size: 22px; font-weight: 700; font-family: monospace; }
.metric-label { font-size: 11px; color: var(--text2); margin-top: 2px; }
.metric-card.highlight { border: 1px solid var(--accent); }

/* Chart */
.chart-container { position: relative; height: 200px; margin: 12px 0; }
canvas { width: 100% !important; height: 100% !important; }

/* Profile badge */
.badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 600; }
.badge.SNOWBALL { background: rgba(248, 81, 73, 0.2); color: var(--red); }
.badge.BALANCED { background: rgba(88, 166, 255, 0.2); color: var(--accent); }
.badge.DECAYING { background: rgba(210, 153, 34, 0.2); color: var(--orange); }
.badge.SHALLOW { background: rgba(139, 148, 158, 0.2); color: var(--text2); }

/* Strategy display */
.strategy-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid var(--border); font-size: 13px; }
.strategy-row:last-child { border-bottom: none; }
.strategy-name { font-weight: 500; }
.strategy-bar { height: 6px; border-radius: 3px; margin: 0 8px; flex: 1; max-width: 120px; }

/* Insight box */
.insight { background: rgba(88, 166, 255, 0.08); border-left: 3px solid var(--accent); padding: 10px 14px; border-radius: 0 6px 6px 0; margin-top: 12px; font-size: 13px; color: var(--text2); }
.insight strong { color: var(--text); }

/* Loading */
.computing { color: var(--text2); font-style: italic; }

/* Tabs */
.tabs { display: flex; gap: 4px; margin-bottom: 16px; }
.tab { padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; background: var(--surface2); border: 1px solid transparent; color: var(--text2); }
.tab.active { background: var(--accent); color: #fff; border-color: var(--accent); }
.tab:hover:not(.active) { border-color: var(--border); color: var(--text); }

/* Separator */
.sep { border-top: 1px solid var(--border); margin: 14px 0; }

/* Back link */
.back { display: inline-block; color: var(--text2); text-decoration: none; font-size: 13px; margin-bottom: 16px; }
.back:hover { color: var(--accent); }

/* Presets */
.preset-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
.preset-btn { padding: 6px 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; color: var(--text); font-size: 11px; text-align: left; line-height: 1.3; transition: border-color 0.15s; }
.preset-btn:hover { border-color: var(--accent); }
.preset-btn .preset-name { font-weight: 600; display: block; }
.preset-btn .preset-desc { color: var(--text2); font-size: 10px; }

/* Snapshot comparison */
.delta { font-size: 11px; font-weight: 600; margin-left: 4px; }
.delta.up { color: var(--green); }
.delta.down { color: var(--red); }
.delta.neutral { color: var(--text2); }
.snapshot-bar { display: flex; align-items: center; gap: 8px; margin-bottom: 12px; }
.snapshot-bar button { padding: 4px 10px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; cursor: pointer; color: var(--text2); font-size: 11px; }
.snapshot-bar button:hover { color: var(--accent); border-color: var(--accent); }
.snapshot-bar .snap-label { font-size: 11px; color: var(--text2); }
</style>
</head>
<body>
<div class="container">
  <a href="{{ '/' | relative_url }}" class="back">&larr; Back to home</a>
  <h1>Game Design Calculator</h1>
  <p class="subtitle">Analyze your game's tension, agency, and fun alignment using ToA metrics.
    <button id="shareBtn" onclick="copyShareLink()" style="margin-left: 12px; padding: 3px 12px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--accent); cursor: pointer; font-size: 12px;">Share Link</button>
  </p>

  <div class="grid">
    <!-- Left Panel: Controls -->
    <div>
      <div class="panel" style="margin-bottom: 16px;">
        <div class="panel-title">Game Model</div>
        <div class="control-group">
          <select id="gameSelect" onchange="onGameChange()">
            <option value="coin">Coin Toss (simplest)</option>
            <option value="bestofn">Best-of-N (coin flips)</option>
            <option value="hp" selected>HP Combat (basic)</option>
            <option value="asymmetric">Asymmetric Combat (ultra-high tension)</option>
            <option value="combat">Tactical Combat (3 actions)</option>
            <option value="coinduel">Coin Duel (resource game)</option>
          </select>
        </div>
        <div id="gameDescription" style="font-size: 12px; color: var(--text2); margin-top: 4px;"></div>
      </div>

      <div class="panel" style="margin-bottom: 16px;" id="paramsPanel">
        <div class="panel-title">Parameters</div>
        <div id="paramsContainer"></div>
      </div>

      <div class="panel" style="margin-bottom: 16px;" id="presetsPanel">
        <div class="panel-title">Presets</div>
        <div class="preset-grid" id="presetGrid"></div>
      </div>

      <div class="panel" id="analysisPanel">
        <div class="panel-title">Analysis Settings</div>
        <div class="control-group">
          <div class="control-label"><span>Nest Level (depth)</span><span id="nestVal">5</span></div>
          <input type="range" id="nestLevel" min="1" max="10" value="5" step="1" oninput="updateLabel('nestLevel','nestVal'); scheduleCompute()">
        </div>
        <div class="control-group">
          <div class="control-label"><span>Perceptual Decay (α)</span><span id="alphaVal">0.50</span></div>
          <input type="range" id="alpha" min="0.1" max="1.0" value="0.5" step="0.05" oninput="updateLabel('alpha','alphaVal',2); scheduleCompute()">
        </div>
      </div>
    </div>

    <!-- Right Panel: Results -->
    <div>
      <div class="snapshot-bar" id="snapshotBar">
        <button onclick="takeSnapshot()" id="snapBtn">Snapshot</button>
        <span class="snap-label" id="snapLabel">Take a snapshot, then change parameters to see the difference.</span>
        <button onclick="clearSnapshot()" id="clearSnapBtn" style="display: none;">Clear</button>
      </div>

      <div class="panel" style="margin-bottom: 16px;">
        <div class="panel-title">
          Metrics
          <span id="profileBadge" class="badge" style="margin-left: 8px;"></span>
          <span id="computeTime" style="float: right; font-size: 11px; font-weight: 400; color: var(--text2);"></span>
        </div>
        <div class="metrics-grid" id="metricsGrid">
          <div class="metric-card highlight"><div class="metric-value" id="mCFS">—</div><div class="metric-label">CFS (Fun Score)</div></div>
          <div class="metric-card"><div class="metric-value" id="mGDS">—</div><div class="metric-label">GDS (Tension)</div></div>
          <div class="metric-card"><div class="metric-value" id="mWGDS">—</div><div class="metric-label">wGDS (Perceived)</div></div>
          <div class="metric-card"><div class="metric-value" id="mPI">—</div><div class="metric-label">PI (Agency)</div></div>
          <div class="metric-card"><div class="metric-value" id="mCPG">—</div><div class="metric-label">CPG (Paradox)</div></div>
          <div class="metric-card"><div class="metric-value" id="mENL">—</div><div class="metric-label">ENL (Depth)</div></div>
        </div>
      </div>

      <div class="panel" style="margin-bottom: 16px;">
        <div class="panel-title">Anticipation Components (A<sub>k</sub>)</div>
        <div class="chart-container"><canvas id="chartCanvas"></canvas></div>
        <div id="componentList" style="font-size: 12px; color: var(--text2); font-family: monospace;"></div>
      </div>

      <div class="panel" id="strategyPanel" style="margin-bottom: 16px; display: none;">
        <div class="panel-title">Strategy Analysis</div>
        <div id="strategyContent"></div>
      </div>

      <div class="panel" id="formulaPanel" style="margin-bottom: 16px; display: none;">
        <div class="panel-title">Closed-Form Formulas (Best-of-N)</div>
        <div id="formulaContent" style="font-size: 13px;"></div>
      </div>

      <div class="panel">
        <div class="panel-title">Design Insight</div>
        <div id="insightContent" class="insight">Select a game model and adjust parameters to see analysis.</div>
      </div>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════
// ToA ENGINE — JavaScript port of Python anticipation_engine
// ═══════════════════════════════════════════════════════════

const MAX_NEST = 20;

function toaAnalyze({ initialState, isTerminal, getTransitions, intrinsicDesire, nestLevel = 5 }) {
  // Step 1: Topological sort via post-order DFS
  const visited = new Set();
  const statesR = [];
  const stateKey = s => typeof s === 'string' ? s : JSON.stringify(s);

  function dfs(s) {
    const k = stateKey(s);
    if (visited.has(k)) return;
    visited.add(k);
    for (const [prob, next] of getTransitions(s)) {
      dfs(next);
    }
    statesR.push(s);
  }
  dfs(initialState);

  const states = [...statesR].reverse();
  const N = states.length;

  // Build index for fast lookup
  const stateIdx = new Map();
  for (let i = 0; i < N; i++) stateIdx.set(stateKey(states[i]), i);

  // Cache transitions
  const transCache = new Map();
  for (const s of states) {
    const k = stateKey(s);
    const trans = getTransitions(s).map(([p, ns]) => [p, stateIdx.get(stateKey(ns))]);
    transCache.set(stateIdx.get(k), trans);
  }

  const gdsComponents = new Float64Array(nestLevel);
  const aValues = new Array(nestLevel);

  for (let comp = 0; comp < nestLevel; comp++) {
    // Seed desire
    const dLocal = new Float64Array(N);
    if (comp === 0) {
      for (let i = 0; i < N; i++) dLocal[i] = intrinsicDesire(states[i]);
    } else {
      for (let i = 0; i < N; i++) dLocal[i] = aValues[comp - 1][i];
    }

    // Propagate desire (reverse topological = statesR order)
    const dGlobal = new Float64Array(N);
    for (let i = 0; i < N; i++) dGlobal[i] = dLocal[i];
    for (const s of statesR) {
      const si = stateIdx.get(stateKey(s));
      for (const [prob, ni] of transCache.get(si)) {
        dGlobal[si] += dGlobal[ni] * prob;
      }
    }

    // Compute A_k (anticipation variance)
    const a = new Float64Array(N);
    for (const s of statesR) {
      const si = stateIdx.get(stateKey(s));
      const trans = transCache.get(si);
      if (trans.length === 0) { a[si] = 0; continue; }

      let sumPd = 0;
      for (const [prob, ni] of trans) {
        sumPd += prob * (dGlobal[ni] - dGlobal[si]);
      }
      let wVar = 0;
      for (const [prob, ni] of trans) {
        const diff = (dGlobal[ni] - dGlobal[si]) - sumPd;
        wVar += prob * diff * diff;
      }
      a[si] = Math.sqrt(wVar);
    }
    aValues[comp] = a;

    // Forward propagation for GDS
    // steps[stateIdx] = Map<stepCount, [reachProb, accA]>
    const steps = new Array(N);
    for (let i = 0; i < N; i++) steps[i] = new Map();

    const initIdx = stateIdx.get(stateKey(initialState));
    steps[initIdx].set(0, [1.0, a[initIdx]]);

    for (const s of states) {
      const si = stateIdx.get(stateKey(s));
      for (const [prob, ni] of transCache.get(si)) {
        for (const [stepI, [reachP, accA]] of steps[si]) {
          const ns = stepI + 1;
          if (!steps[ni].has(ns)) steps[ni].set(ns, [0, 0]);
          const entry = steps[ni].get(ns);
          entry[0] += reachP * prob;
          entry[1] += accA * prob + a[ni] * reachP * prob;
        }
      }
    }

    // Sum at terminals
    let totalEndProb = 0;
    for (let i = 0; i < N; i++) {
      if (isTerminal(states[i])) {
        for (const [stepI, [reachP, accA]] of steps[i]) {
          totalEndProb += reachP;
          if (stepI > 0) gdsComponents[comp] += accA / stepI;
        }
      }
    }
  }

  return {
    gdsComponents: Array.from(gdsComponents),
    gds: gdsComponents.reduce((a, b) => a + b, 0),
    stateCount: N,
    dGlobal0: null, // could store if needed
  };
}


// ═══════════════════════════════════════════════
// GAME MODELS
// ═══════════════════════════════════════════════

function coinTossGame() {
  return {
    initialState: 'initial',
    isTerminal: s => s !== 'initial',
    getTransitions: s => s !== 'initial' ? [] : [[0.5, 'win'], [0.5, 'loss']],
    intrinsicDesire: s => s === 'win' ? 1.0 : 0.0,
  };
}

function bestOfNGame(n) {
  // State: [winsP1, winsP2], need ceil(n/2) to win
  const target = Math.ceil(n / 2);
  return {
    initialState: [0, 0],
    isTerminal: s => s[0] >= target || s[1] >= target,
    getTransitions: s => {
      if (s[0] >= target || s[1] >= target) return [];
      return [[0.5, [s[0] + 1, s[1]]], [0.5, [s[0], s[1] + 1]]];
    },
    intrinsicDesire: s => s[0] >= target ? 1.0 : 0.0,
  };
}

function hpGame(hp1, hp2) {
  return {
    initialState: [hp1, hp2],
    isTerminal: s => s[0] <= 0 || s[1] <= 0,
    getTransitions: s => {
      if (s[0] <= 0 || s[1] <= 0) return [];
      return [
        [1/3, [s[0], s[1] - 1]],
        [1/3, [s[0] - 1, s[1] - 1]],
        [1/3, [s[0] - 1, s[1]]],
      ];
    },
    intrinsicDesire: s => (s[0] > 0 && s[1] <= 0) ? 1.0 : 0.0,
  };
}

function asymmetricCombatGame(maxHp) {
  // Each turn: random outcome hurts ONE player (asymmetric)
  const OUTCOMES = [
    [0.25, 0, -1],    // P2 takes 1
    [0.25, -1, 0],    // P1 takes 1
    [0.14, 0, -2],    // P2 takes 2
    [0.14, -2, 0],    // P1 takes 2
    [0.06, +1, -2],   // P1 heals 1, P2 takes 2
    [0.06, -2, +1],   // P2 heals 1, P1 takes 2
    [0.05, 0, -maxHp],// P2 one-shot
    [0.05, -maxHp, 0],// P1 one-shot
  ];

  return {
    initialState: [maxHp, maxHp],
    isTerminal: s => s[0] <= 0 || s[1] <= 0,
    getTransitions: s => {
      if (s[0] <= 0 || s[1] <= 0) return [];
      const trans = [];
      let total = 0;
      for (const [prob, d1, d2] of OUTCOMES) {
        const n1 = Math.max(0, Math.min(maxHp, s[0] + d1));
        const n2 = Math.max(0, Math.min(maxHp, s[1] + d2));
        trans.push([prob, [n1, n2]]);
        total += prob;
      }
      // Normalize
      if (Math.abs(total - 1.0) > 0.001) {
        for (let i = 0; i < trans.length; i++) trans[i][0] /= total;
      }
      return trans;
    },
    intrinsicDesire: s => (s[0] > 0 && s[1] <= 0) ? 1.0 : 0.0,
  };
}

function combatGame(maxHp, params) {
  const { strikeDmg, heavyDmg, heavyHit, guardCounter, guardBlock, chipDmg } = params;

  // Build action outcome table
  // (a1, a2) → [(prob, (dhp1, dhp2)), ...]
  const actions = {};
  const set = (a1, a2, outcomes) => { actions[a1 * 3 + a2] = outcomes; };

  set(0, 0, [[1.0, [-strikeDmg, -strikeDmg]]]);
  set(0, 1, [[heavyHit, [-heavyDmg, -strikeDmg]], [1 - heavyHit, [0, -strikeDmg]]]);
  set(0, 2, [[1.0, [-guardCounter, 0]]]);
  set(1, 0, [[heavyHit, [-strikeDmg, -heavyDmg]], [1 - heavyHit, [-strikeDmg, 0]]]);
  set(1, 1, [
    [heavyHit * heavyHit, [-heavyDmg, -heavyDmg]],
    [heavyHit * (1 - heavyHit), [-heavyDmg, 0]],
    [(1 - heavyHit) * heavyHit, [0, -heavyDmg]],
    [(1 - heavyHit) * (1 - heavyHit), [-chipDmg, -chipDmg]],
  ]);
  const reduced = Math.floor(heavyDmg * guardBlock);
  set(1, 2, [[heavyHit, [0, -reduced]], [1 - heavyHit, [-guardCounter, 0]]]);
  set(2, 0, [[1.0, [0, -guardCounter]]]);
  set(2, 1, [[heavyHit, [-reduced, 0]], [1 - heavyHit, [0, -guardCounter]]]);
  set(2, 2, [[1.0, [-chipDmg, -chipDmg]]]);

  function getTransitionsForPolicy(state, policy) {
    const [hp1, hp2] = state;
    if (hp1 <= 0 || hp2 <= 0) return [];

    const transitions = [];
    const oppProbs = [1/3, 1/3, 1/3]; // opponent always random

    for (let a1 = 0; a1 < 3; a1++) {
      const p1prob = policy[a1];
      if (p1prob < 1e-10) continue;
      for (let a2 = 0; a2 < 3; a2++) {
        const p2prob = oppProbs[a2];
        if (p2prob < 1e-10) continue;
        const key = a1 * 3 + a2;
        for (const [oprob, [dhp1, dhp2]] of actions[key]) {
          const nh1 = Math.max(0, Math.min(maxHp, hp1 + dhp1));
          const nh2 = Math.max(0, Math.min(maxHp, hp2 + dhp2));
          transitions.push([p1prob * p2prob * oprob, [nh1, nh2]]);
        }
      }
    }

    // Merge duplicate states
    return mergeTransitions(transitions);
  }

  return {
    maxHp,
    nActions: 3,
    actionNames: ['Strike', 'Heavy', 'Guard'],
    getTransitionsForPolicy,
    isTerminal: s => s[0] <= 0 || s[1] <= 0,
    intrinsicDesire: s => (s[0] > 0 && s[1] <= 0) ? 1.0 : 0.0,
    initialState: [maxHp, maxHp],
  };
}

function mergeTransitions(transitions) {
  const map = new Map();
  for (const [p, s] of transitions) {
    const k = JSON.stringify(s);
    map.set(k, (map.get(k) || 0) + p);
  }
  const result = [];
  let total = 0;
  for (const [k, p] of map) {
    result.push([p, JSON.parse(k)]);
    total += p;
  }
  // Normalize
  if (Math.abs(total - 1.0) > 0.001) {
    for (let i = 0; i < result.length; i++) result[i][0] /= total;
  }
  return result;
}


// ═══════════════════════════════════════════════
// COIN DUEL — resource management game
// ═══════════════════════════════════════════════

function binomCoeff(n, k) {
  if (k < 0 || k > n) return 0;
  if (k === 0 || k === n) return 1;
  if (k > n - k) k = n - k;
  let r = 1;
  for (let i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return Math.round(r);
}

function flipOutcomes(n) {
  // [(probability, headsCount)] for flipping n coins
  const out = [];
  const denom = Math.pow(2, n);
  for (let h = 0; h <= n; h++) {
    out.push([binomCoeff(n, h) / denom, h]);
  }
  return out;
}

function roundResult(n1, n2) {
  // Returns [pWin1, pDraw, pWin2]
  const o1 = flipOutcomes(n1);
  const o2 = flipOutcomes(n2);
  let pw1 = 0, pd = 0, pw2 = 0;
  for (const [p1, h1] of o1) {
    for (const [p2, h2] of o2) {
      const j = p1 * p2;
      if (h1 > h2) pw1 += j;
      else if (h1 === h2) pd += j;
      else pw2 += j;
    }
  }
  return [pw1, pd, pw2];
}

function coinDuelGame(params) {
  const { roundsToWin, initialBank, maxBank, maxWager, refill } = params;

  function effectiveWager(wagerIdx, bank) {
    const desired = wagerIdx + 1; // action 0→wager 1, 1→wager 2, etc.
    return bank > 0 ? Math.max(1, Math.min(desired, bank)) : 0;
  }

  function transitionsForWagerPair(state, w1, w2) {
    const [s1, s2, b1, b2] = state;
    const newB1 = Math.min(b1 - w1 + refill, maxBank);
    const newB2 = Math.min(b2 - w2 + refill, maxBank);

    if (w1 === 0 || w2 === 0) {
      if (w1 === 0 && w2 === 0) return [[1.0, [s1, s2, Math.min(b1 + refill, maxBank), Math.min(b2 + refill, maxBank)]]];
      if (w1 === 0) return [[1.0, [s1, s2 + 1, Math.min(b1 + refill, maxBank), newB2]]];
      return [[1.0, [s1 + 1, s2, newB1, Math.min(b2 + refill, maxBank)]]];
    }

    const [pw1, , pw2] = roundResult(w1, w2);
    const decisive = pw1 + pw2;
    const p1 = decisive > 0 ? pw1 / decisive : 0.5;
    const p2 = decisive > 0 ? pw2 / decisive : 0.5;

    return [
      [p1, [s1 + 1, s2, newB1, newB2]],
      [p2, [s1, s2 + 1, newB1, newB2]],
    ];
  }

  function getTransitionsForPolicy(state, policy) {
    const [s1, s2, b1, b2] = state;
    if (s1 >= roundsToWin || s2 >= roundsToWin) return [];

    const nActions = maxWager;
    const oppProbs = new Array(nActions).fill(1 / nActions);
    const allTrans = [];

    for (let a1 = 0; a1 < nActions; a1++) {
      const p1prob = policy[a1];
      if (p1prob < 1e-10) continue;
      const w1 = effectiveWager(a1, b1);
      for (let a2 = 0; a2 < nActions; a2++) {
        const p2prob = oppProbs[a2];
        if (p2prob < 1e-10) continue;
        const w2 = effectiveWager(a2, b2);
        const trans = transitionsForWagerPair(state, w1, w2);
        for (const [prob, next] of trans) {
          allTrans.push([p1prob * p2prob * prob, next]);
        }
      }
    }

    return mergeTransitions(allTrans);
  }

  const actionNames = [];
  for (let i = 1; i <= maxWager; i++) actionNames.push(`Wager ${i}`);

  return {
    nActions: maxWager,
    actionNames,
    getTransitionsForPolicy,
    isTerminal: s => s[0] >= roundsToWin || s[1] >= roundsToWin,
    intrinsicDesire: s => (s[0] >= roundsToWin && s[1] < roundsToWin) ? 1.0 : 0.0,
    initialState: [0, 0, initialBank, initialBank],
  };
}


// ═══════════════════════════════════════════════
// AGENCY METRICS (PI, CPG)
// ═══════════════════════════════════════════════

function computeGDSForPolicy(combatModel, policy, nestLevel) {
  const game = {
    initialState: combatModel.initialState,
    isTerminal: combatModel.isTerminal,
    getTransitions: s => combatModel.getTransitionsForPolicy(s, policy),
    intrinsicDesire: combatModel.intrinsicDesire,
  };
  return toaAnalyze({ ...game, nestLevel });
}

function computePolicyImpact(combatModel, nestLevel) {
  const n = combatModel.nActions;
  const gdsValues = [];
  for (let a = 0; a < n; a++) {
    const policy = new Array(n).fill(0);
    policy[a] = 1.0;
    const result = computeGDSForPolicy(combatModel, policy, nestLevel);
    gdsValues.push({ action: a, gds: result.gds, name: combatModel.actionNames[a] });
  }

  // Also random
  const rndPolicy = new Array(n).fill(1 / n);
  const rndResult = computeGDSForPolicy(combatModel, rndPolicy, nestLevel);
  gdsValues.push({ action: -1, gds: rndResult.gds, name: 'Random' });

  const gdsList = gdsValues.map(v => v.gds);
  const pi = Math.max(...gdsList) - Math.min(...gdsList);
  return { pi, gdsValues };
}

function computeCPG(combatModel, nestLevel, resolution = 10) {
  const n = combatModel.nActions;
  const results = [];

  // Generate grid points over n-simplex
  function* simplexGrid(dims, res, prefix = []) {
    if (dims === 1) {
      const remaining = res - prefix.reduce((a, b) => a + b, 0);
      yield [...prefix, remaining / res];
      return;
    }
    const used = prefix.reduce((a, b) => a + b, 0);
    for (let i = 0; i <= res - used; i++) {
      yield* simplexGrid(dims - 1, res, [...prefix, i]);
    }
  }

  for (const policy of simplexGrid(n, resolution)) {
    const result = computeGDSForPolicy(combatModel, policy, nestLevel);
    const d0 = computeWinProb(combatModel, policy);
    results.push({ gds: result.gds, d0, policy: [...policy] });
  }

  // Fun-optimal: highest GDS
  results.sort((a, b) => b.gds - a.gds);
  const funOpt = results[0];

  // Win-optimal: highest D₀
  results.sort((a, b) => b.d0 - a.d0);
  const winOpt = results[0];

  const cpg = Math.abs(funOpt.d0 - winOpt.d0);
  return { cpg, funOptimal: funOpt, winOptimal: winOpt };
}

function computeWinProb(combatModel, policy) {
  // Simple DP: propagate win probability backward
  const visited = new Map();

  function dp(state) {
    if (combatModel.isTerminal(state)) {
      return combatModel.intrinsicDesire(state);
    }
    const k = JSON.stringify(state);
    if (visited.has(k)) return visited.get(k);

    // Mark visiting to avoid infinite loops (shouldn't happen in acyclic games)
    visited.set(k, 0);

    const trans = combatModel.getTransitionsForPolicy(state, policy);
    let wp = 0;
    for (const [prob, next] of trans) {
      wp += prob * dp(next);
    }
    visited.set(k, wp);
    return wp;
  }

  return dp(combatModel.initialState);
}


// ═══════════════════════════════════════════════
// DERIVED METRICS
// ═══════════════════════════════════════════════

function weightedGDS(components, alpha) {
  let total = 0;
  for (let k = 0; k < components.length; k++) {
    total += Math.pow(alpha, k) * components[k];
  }
  return total;
}

function effectiveNestLevel(components, threshold = 0.01) {
  const total = components.reduce((a, b) => a + b, 0);
  if (total < 1e-10) return 0;
  let cumulative = 0;
  for (let k = 0; k < components.length; k++) {
    cumulative += components[k];
    if (cumulative / total >= 1 - threshold) return k + 1;
  }
  return components.length;
}

function classifyProfile(components) {
  const ratios = [];
  for (let k = 1; k < Math.min(5, components.length); k++) {
    if (components[k - 1] > 1e-10) {
      ratios.push(components[k] / components[k - 1]);
    }
  }
  const avg = ratios.length ? ratios.reduce((a, b) => a + b, 0) / ratios.length : 0;
  if (avg > 1.2) return 'SNOWBALL';
  if (avg > 0.8) return 'BALANCED';
  if (avg > 0.3) return 'DECAYING';
  return 'SHALLOW';
}


// ═══════════════════════════════════════════════
// UI
// ═══════════════════════════════════════════════

const GAME_CONFIGS = {
  coin: {
    description: 'Single coin flip. The theoretical minimum game — one moment of pure uncertainty.',
    params: [],
    hasAgency: false,
  },
  bestofn: {
    description: 'Best-of-N coin flips. As N increases, anticipation builds across rounds. Has exact closed-form formulas for all metrics.',
    params: [
      { id: 'rounds', label: 'Rounds (N)', min: 1, max: 15, value: 5, step: 2 },
    ],
    hasAgency: false,
  },
  hp: {
    description: 'Two players trade hits. Each turn: one of three equally likely outcomes (P1 hits, both hit, P2 hits).',
    params: [
      { id: 'hp', label: 'HP per player', min: 2, max: 8, value: 5, step: 1 },
    ],
    hasAgency: false,
  },
  asymmetric: {
    description: 'Each turn randomly hurts ONE player — maximum per-turn uncertainty. GDS grows superlinearly with HP. Demonstrates the Unbound Conjecture.',
    params: [
      { id: 'hp', label: 'HP per player', min: 2, max: 7, value: 5, step: 1 },
    ],
    hasAgency: false,
  },
  combat: {
    description: 'Tactical combat with Strike/Heavy/Guard. The only model with player choices — enables PI and CPG analysis.',
    params: [
      { id: 'maxHp', label: 'HP per player', min: 3, max: 7, value: 5, step: 1 },
      { id: 'heavyDmg', label: 'Heavy Damage', min: 2, max: 5, value: 2, step: 1 },
      { id: 'heavyHit', label: 'Heavy Hit Chance', min: 0.3, max: 0.9, value: 0.5, step: 0.1, decimals: 1 },
      { id: 'guardCounter', label: 'Guard Counter Damage', min: 1, max: 3, value: 1, step: 1 },
      { id: 'guardBlock', label: 'Guard Block Ratio', min: 0.3, max: 0.8, value: 0.5, step: 0.1, decimals: 1 },
    ],
    hasAgency: true,
  },
  coinduel: {
    description: 'Resource game: both players wager coins each round. More coins = better odds, but the bank is limited. First to N round wins takes the game. Player chooses wager amount.',
    params: [
      { id: 'roundsToWin', label: 'Rounds to Win', min: 2, max: 4, value: 3, step: 1 },
      { id: 'maxWager', label: 'Max Wager', min: 2, max: 4, value: 3, step: 1 },
      { id: 'initialBank', label: 'Starting Coins', min: 3, max: 8, value: 5, step: 1 },
      { id: 'refill', label: 'Coins per Turn', min: 0, max: 2, value: 1, step: 1 },
    ],
    hasAgency: true,
  },
};

let computeTimeout = null;

function updateLabel(sliderId, labelId, decimals = 0) {
  const v = document.getElementById(sliderId).value;
  document.getElementById(labelId).textContent = Number(v).toFixed(decimals);
}

function onGameChange() {
  const game = document.getElementById('gameSelect').value;
  const cfg = GAME_CONFIGS[game];

  document.getElementById('gameDescription').textContent = cfg.description;

  // Build params UI
  const container = document.getElementById('paramsContainer');
  container.innerHTML = '';
  for (const p of cfg.params) {
    const dec = p.decimals || 0;
    const div = document.createElement('div');
    div.className = 'control-group';
    div.innerHTML = `
      <div class="control-label"><span>${p.label}</span><span id="param_${p.id}_val">${Number(p.value).toFixed(dec)}</span></div>
      <input type="range" id="param_${p.id}" min="${p.min}" max="${p.max}" value="${p.value}" step="${p.step}"
        oninput="document.getElementById('param_${p.id}_val').textContent = Number(this.value).toFixed(${dec}); scheduleCompute()">
    `;
    container.appendChild(div);
  }

  document.getElementById('strategyPanel').style.display = cfg.hasAgency ? '' : 'none';

  // Show/hide CFS, PI, CPG cards based on agency
  const piCard = document.getElementById('mPI').parentElement;
  const cpgCard = document.getElementById('mCPG').parentElement;
  const cfsCard = document.getElementById('mCFS').parentElement;
  piCard.style.display = cfg.hasAgency ? '' : 'none';
  cpgCard.style.display = cfg.hasAgency ? '' : 'none';
  cfsCard.style.display = cfg.hasAgency ? '' : 'none';

  scheduleCompute();
}

function scheduleCompute() {
  if (computeTimeout) clearTimeout(computeTimeout);
  computeTimeout = setTimeout(runCompute, 150);
}

function getParam(id, fallback) {
  const el = document.getElementById('param_' + id);
  return el ? Number(el.value) : fallback;
}

function runCompute() {
  const gameType = document.getElementById('gameSelect').value;
  const nestLevel = Number(document.getElementById('nestLevel').value);
  const alpha = Number(document.getElementById('alpha').value);

  const t0 = performance.now();

  let result, agencyResult = null;
  let game;

  switch (gameType) {
    case 'coin':
      game = coinTossGame();
      result = toaAnalyze({ ...game, nestLevel });
      break;
    case 'bestofn': {
      const n = getParam('rounds', 5);
      game = bestOfNGame(n);
      result = toaAnalyze({ ...game, nestLevel });
      break;
    }
    case 'hp': {
      const hp = getParam('hp', 5);
      game = hpGame(hp, hp);
      result = toaAnalyze({ ...game, nestLevel });
      break;
    }
    case 'asymmetric': {
      const hp = getParam('hp', 5);
      game = asymmetricCombatGame(hp);
      result = toaAnalyze({ ...game, nestLevel });
      break;
    }
    case 'combat': {
      const maxHp = getParam('maxHp', 5);
      const cm = combatGame(maxHp, {
        strikeDmg: 1,
        heavyDmg: getParam('heavyDmg', 2),
        heavyHit: getParam('heavyHit', 0.5),
        guardCounter: getParam('guardCounter', 1),
        guardBlock: getParam('guardBlock', 0.5),
        chipDmg: 1,
      });
      // GDS under random policy
      result = computeGDSForPolicy(cm, [1/3, 1/3, 1/3], nestLevel);

      // Agency metrics
      const { pi, gdsValues } = computePolicyImpact(cm, nestLevel);
      const { cpg, funOptimal, winOptimal } = computeCPG(cm, nestLevel, 10);
      agencyResult = { pi, gdsValues, cpg, funOptimal, winOptimal };
      break;
    }
    case 'coinduel': {
      const cd = coinDuelGame({
        roundsToWin: getParam('roundsToWin', 3),
        maxWager: getParam('maxWager', 3),
        initialBank: getParam('initialBank', 5),
        maxBank: 8,
        refill: getParam('refill', 1),
      });
      // GDS under random policy
      const rndPolicy = new Array(cd.nActions).fill(1 / cd.nActions);
      result = computeGDSForPolicy(cd, rndPolicy, nestLevel);

      // Agency metrics
      const { pi, gdsValues } = computePolicyImpact(cd, nestLevel);
      const cpgRes = getParam('maxWager', 3) <= 3 ? 8 : 6; // lower resolution for 4 actions
      const { cpg, funOptimal, winOptimal } = computeCPG(cd, nestLevel, cpgRes);
      agencyResult = { pi, gdsValues, cpg, funOptimal, winOptimal };
      break;
    }
  }

  const elapsed = performance.now() - t0;
  displayResults(result, agencyResult, alpha, elapsed);

  // Show formula panel for Best-of-N only
  if (gameType === 'bestofn') {
    const n = getParam('rounds', 5);
    displayFormulas(n);
  } else {
    document.getElementById('formulaPanel').style.display = 'none';
  }
}

function displayResults(result, agency, alpha, elapsed) {
  const comp = result.gdsComponents;
  const gds = result.gds;
  const wgds = weightedGDS(comp, alpha);
  const enl = effectiveNestLevel(comp);
  const profile = classifyProfile(comp);

  document.getElementById('mGDS').textContent = gds.toFixed(3);
  document.getElementById('mWGDS').textContent = wgds.toFixed(3);
  document.getElementById('mENL').textContent = enl;
  document.getElementById('computeTime').textContent = `${elapsed.toFixed(0)}ms · ${result.stateCount} states`;

  const badge = document.getElementById('profileBadge');
  badge.textContent = profile;
  badge.className = `badge ${profile}`;

  if (agency) {
    const piRatio = gds > 1e-10 ? agency.pi / gds : 0;
    const cpgNorm = Math.min(agency.cpg, 1.0);
    const cfs = wgds * (1 + piRatio) * (1 - cpgNorm);

    document.getElementById('mPI').textContent = agency.pi.toFixed(3);
    document.getElementById('mCPG').textContent = agency.cpg.toFixed(3);
    document.getElementById('mCFS').textContent = cfs.toFixed(3);

    // Strategy panel
    const sc = document.getElementById('strategyContent');
    let html = '<div style="margin-bottom: 8px; font-size: 13px;">';
    html += '<strong>GDS by pure strategy:</strong></div>';
    const maxGDS = Math.max(...agency.gdsValues.map(v => v.gds));
    for (const v of agency.gdsValues) {
      const pct = maxGDS > 0 ? (v.gds / maxGDS * 100) : 0;
      const color = v.gds === maxGDS ? 'var(--green)' : 'var(--text2)';
      html += `<div class="strategy-row">
        <span class="strategy-name">${v.name}</span>
        <div class="strategy-bar" style="background: ${color}; width: ${pct}%;"></div>
        <span style="font-family: monospace; color: ${color};">${v.gds.toFixed(3)}</span>
      </div>`;
    }

    html += '<div class="sep"></div>';
    html += `<div style="font-size: 13px;">
      <strong>Fun-optimal:</strong> [${agency.funOptimal.policy.map(p => p.toFixed(1)).join(', ')}] → GDS ${agency.funOptimal.gds.toFixed(3)}, Win ${(agency.funOptimal.d0 * 100).toFixed(1)}%<br>
      <strong>Win-optimal:</strong> [${agency.winOptimal.policy.map(p => p.toFixed(1)).join(', ')}] → GDS ${agency.winOptimal.gds.toFixed(3)}, Win ${(agency.winOptimal.d0 * 100).toFixed(1)}%
    </div>`;
    sc.innerHTML = html;
    document.getElementById('strategyPanel').style.display = '';
  } else {
    document.getElementById('mPI').textContent = '—';
    document.getElementById('mCPG').textContent = '—';
    document.getElementById('mCFS').textContent = '—';
    document.getElementById('strategyPanel').style.display = 'none';
  }

  // Chart
  drawChart(comp);

  // Component list
  const list = comp.map((c, i) => `A${i + 1}=${c.toFixed(4)}`).join('  ');
  document.getElementById('componentList').textContent = list;

  // Insight
  generateInsight(gds, wgds, agency, profile, comp);
}

function drawChart(components) {
  const canvas = document.getElementById('chartCanvas');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);

  const W = rect.width;
  const H = rect.height;
  const pad = { top: 10, right: 20, bottom: 30, left: 50 };
  const cw = W - pad.left - pad.right;
  const ch = H - pad.top - pad.bottom;

  ctx.clearRect(0, 0, W, H);

  const maxVal = Math.max(...components, 0.01);
  const barWidth = Math.min(cw / components.length * 0.7, 40);
  const gap = cw / components.length;

  // Grid lines
  ctx.strokeStyle = '#21262d';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = pad.top + ch - (ch * i / 4);
    ctx.beginPath();
    ctx.moveTo(pad.left, y);
    ctx.lineTo(W - pad.right, y);
    ctx.stroke();

    ctx.fillStyle = '#8b949e';
    ctx.font = '10px monospace';
    ctx.textAlign = 'right';
    ctx.fillText((maxVal * i / 4).toFixed(3), pad.left - 6, y + 3);
  }

  // Bars
  const gradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + ch);
  gradient.addColorStop(0, '#58a6ff');
  gradient.addColorStop(1, '#1f6feb');

  for (let i = 0; i < components.length; i++) {
    const x = pad.left + gap * i + (gap - barWidth) / 2;
    const barH = (components[i] / maxVal) * ch;
    const y = pad.top + ch - barH;

    ctx.fillStyle = gradient;
    ctx.beginPath();
    const r = 3;
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + barWidth - r, y);
    ctx.arcTo(x + barWidth, y, x + barWidth, y + r, r);
    ctx.lineTo(x + barWidth, y + barH);
    ctx.lineTo(x, y + barH);
    ctx.lineTo(x, y + r);
    ctx.arcTo(x, y, x + r, y, r);
    ctx.fill();

    // Label
    ctx.fillStyle = '#8b949e';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`A${i + 1}`, x + barWidth / 2, H - pad.bottom + 15);
  }
}

function generateInsight(gds, wgds, agency, profile, comp) {
  const el = document.getElementById('insightContent');
  let insights = [];

  if (gds < 0.1) {
    insights.push('Very low tension — the outcome feels predetermined. Consider adding more uncertainty or longer games.');
  } else if (gds < 0.3) {
    insights.push('Moderate tension. The game has some suspense but resolves quickly.');
  } else if (gds < 0.6) {
    insights.push('Good tension level — comparable to well-designed competitive games.');
  } else {
    insights.push('High tension — the game creates strong suspense through deep uncertainty structures.');
  }

  if (profile === 'SNOWBALL') {
    insights.push('<strong>Snowball profile:</strong> Later rounds create MORE tension than earlier ones. This can feel like escalating drama.');
  } else if (profile === 'DECAYING') {
    insights.push('<strong>Decaying profile:</strong> Most tension is front-loaded. Consider adding mechanics that keep later rounds interesting.');
  } else if (profile === 'SHALLOW') {
    insights.push('<strong>Shallow profile:</strong> Nearly all tension comes from A₁ (immediate outcomes). The game lacks deeper anticipation layers.');
  }

  if (agency) {
    if (agency.cpg > 0.3) {
      insights.push(`<strong>High CPG (${agency.cpg.toFixed(2)}):</strong> The most fun strategy loses. Players must choose between excitement and winning. Try increasing Heavy\'s expected value to align fun with winning.`);
    } else if (agency.cpg < 0.05) {
      insights.push(`<strong>Near-zero CPG:</strong> Fun and winning are aligned — the exciting strategy is also the best strategy. This is the ideal design target.`);
    }

    if (agency.pi < 0.05) {
      insights.push(`<strong>Low PI (${agency.pi.toFixed(3)}):</strong> Player choices barely affect the experience. Consider making actions more differentiated.`);
    } else if (agency.pi > 0.15) {
      insights.push(`<strong>Strong agency (PI=${agency.pi.toFixed(3)}):</strong> Player choices meaningfully shape their experience.`);
    }
  }

  el.innerHTML = insights.join('<br><br>');

  // Show snapshot deltas if active
  showDeltas();
}


// ═══════════════════════════════════════════════
// CLOSED-FORM FORMULAS (Best-of-N)
// ═══════════════════════════════════════════════

function binom(n, k) {
  if (k < 0 || k > n) return 0;
  if (k === 0 || k === n) return 1;
  if (k > n - k) k = n - k;
  let r = 1;
  for (let i = 0; i < k; i++) r = r * (n - i) / (i + 1);
  return Math.round(r);
}

function a1Exact(a, b) {
  // A₁(a,b) = C(a+b-2, a-1) / 2^{a+b-1}
  if (a <= 0 || b <= 0) return 0;
  return binom(a + b - 2, a - 1) / Math.pow(2, a + b - 1);
}

function a2Exact(a, b) {
  // A₂(a,b) = |a - b| × A₁(a,b)
  return Math.abs(a - b) * a1Exact(a, b);
}

function gExact(a, b) {
  // G(a,b) = (a+b-1) × A₁(a,b) — expected total future A₁
  return (a + b - 1) * a1Exact(a, b);
}

function amBoundary(m, b) {
  // A_m(1, b) = C(b-1, m-1) / 2^b
  return binom(b - 1, m - 1) / Math.pow(2, b);
}

function displayFormulas(n) {
  const panel = document.getElementById('formulaPanel');
  const content = document.getElementById('formulaContent');

  const target = Math.ceil(n / 2);
  // Initial state: both players need target wins → a = target, b = target
  const a = target, b = target;

  const a1 = a1Exact(a, b);
  const a2 = a2Exact(a, b);
  const g = gExact(a, b);

  let html = '';
  html += `<div style="margin-bottom: 10px; color: var(--text2);">For Best-of-${n} (target = ${target}), initial state (${a}, ${b}):</div>`;

  html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">';

  html += `<div style="background: var(--surface2); padding: 8px; border-radius: 6px;">
    <div style="font-size: 11px; color: var(--text2);">A₁ = C(${a+b-2}, ${a-1}) / 2<sup>${a+b-1}</sup></div>
    <div style="font-family: monospace; font-size: 16px; font-weight: 600; color: var(--accent);">${a1.toFixed(6)}</div>
    <div style="font-size: 10px; color: var(--text2);">Win probability shift per step</div>
  </div>`;

  html += `<div style="background: var(--surface2); padding: 8px; border-radius: 6px;">
    <div style="font-size: 11px; color: var(--text2);">A₂ = |${a} − ${b}| × A₁</div>
    <div style="font-family: monospace; font-size: 16px; font-weight: 600; color: var(--purple);">${a2.toFixed(6)}</div>
    <div style="font-size: 10px; color: var(--text2);">Drama asymmetry (0 at tie)</div>
  </div>`;

  html += `<div style="background: var(--surface2); padding: 8px; border-radius: 6px;">
    <div style="font-size: 11px; color: var(--text2);">G = (${a+b-1}) × A₁</div>
    <div style="font-family: monospace; font-size: 16px; font-weight: 600; color: var(--green);">${g.toFixed(6)}</div>
    <div style="font-size: 10px; color: var(--text2);">Expected total drama ahead</div>
  </div>`;

  // Win probability
  const d = binom(2*target - 2, target - 1) / Math.pow(2, 2*target - 1);
  html += `<div style="background: var(--surface2); padding: 8px; border-radius: 6px;">
    <div style="font-size: 11px; color: var(--text2);">Win Prob = 0.500</div>
    <div style="font-family: monospace; font-size: 16px; font-weight: 600; color: var(--orange);">50.0%</div>
    <div style="font-size: 10px; color: var(--text2);">Fair coin → symmetric</div>
  </div>`;
  html += '</div>';

  // Boundary states: show A_m(1, target) = Pascal's triangle
  if (target >= 2) {
    html += '<div class="sep"></div>';
    html += '<div style="font-size: 12px; color: var(--text2); margin-bottom: 6px;"><strong>Boundary State</strong> (1, ' + target + ') — one win away from victory:</div>';
    html += '<div style="font-family: monospace; font-size: 12px; display: flex; gap: 12px; flex-wrap: wrap;">';
    const maxM = Math.min(target, 6);
    for (let m = 1; m <= maxM; m++) {
      const val = amBoundary(m, target);
      html += `<span style="color: ${m === 1 ? 'var(--accent)' : m === 2 ? 'var(--purple)' : 'var(--text2)'};">A<sub>${m}</sub> = C(${target-1},${m-1})/2<sup>${target}</sup> = ${val.toFixed(4)}</span>`;
    }
    html += '</div>';
    html += `<div style="font-size: 11px; color: var(--text2); margin-top: 4px;">These form row ${target-1} of Pascal's triangle, divided by 2<sup>${target}</sup>.</div>`;
  }

  content.innerHTML = html;
  panel.style.display = '';
}


// ═══════════════════════════════════════════════
// URL STATE SHARING
// ═══════════════════════════════════════════════

function encodeState() {
  const gameType = document.getElementById('gameSelect').value;
  const nestLevel = document.getElementById('nestLevel').value;
  const alpha = document.getElementById('alpha').value;
  const cfg = GAME_CONFIGS[gameType];

  const parts = [gameType, nestLevel, alpha];
  for (const p of cfg.params) {
    const el = document.getElementById('param_' + p.id);
    if (el) parts.push(p.id + '=' + el.value);
  }
  return parts.join(',');
}

function decodeState(hash) {
  if (!hash || hash.length < 2) return false;
  const str = hash.startsWith('#') ? hash.slice(1) : hash;
  const parts = str.split(',');
  if (parts.length < 3) return false;

  const [gameType, nestLevel, alpha, ...paramParts] = parts;
  if (!GAME_CONFIGS[gameType]) return false;

  document.getElementById('gameSelect').value = gameType;
  document.getElementById('nestLevel').value = nestLevel;
  document.getElementById('nestLevel').dispatchEvent(new Event('input'));
  document.getElementById('alpha').value = alpha;
  document.getElementById('alpha').dispatchEvent(new Event('input'));

  // Trigger game change to build param UI
  const cfg = GAME_CONFIGS[gameType];
  document.getElementById('gameDescription').textContent = cfg.description;
  const container = document.getElementById('paramsContainer');
  container.innerHTML = '';
  for (const p of cfg.params) {
    const dec = p.decimals || 0;
    const div = document.createElement('div');
    div.className = 'control-group';
    div.innerHTML = `
      <div class="control-label"><span>${p.label}</span><span id="param_${p.id}_val">${Number(p.value).toFixed(dec)}</span></div>
      <input type="range" id="param_${p.id}" min="${p.min}" max="${p.max}" value="${p.value}" step="${p.step}"
        oninput="document.getElementById('param_${p.id}_val').textContent = Number(this.value).toFixed(${dec}); scheduleCompute()">
    `;
    container.appendChild(div);
  }

  document.getElementById('strategyPanel').style.display = cfg.hasAgency ? '' : 'none';
  const piCard = document.getElementById('mPI').parentElement;
  const cpgCard = document.getElementById('mCPG').parentElement;
  const cfsCard = document.getElementById('mCFS').parentElement;
  piCard.style.display = cfg.hasAgency ? '' : 'none';
  cpgCard.style.display = cfg.hasAgency ? '' : 'none';
  cfsCard.style.display = cfg.hasAgency ? '' : 'none';

  // Set param values from URL
  for (const pp of paramParts) {
    const [id, val] = pp.split('=');
    if (!id || !val) continue;
    const el = document.getElementById('param_' + id);
    if (el) {
      el.value = val;
      const valEl = document.getElementById('param_' + id + '_val');
      if (valEl) {
        const p = cfg.params.find(cp => cp.id === id);
        valEl.textContent = Number(val).toFixed(p?.decimals || 0);
      }
    }
  }

  return true;
}

function updateURL() {
  const encoded = encodeState();
  history.replaceState(null, '', '#' + encoded);
}

function copyShareLink() {
  const url = window.location.href.split('#')[0] + '#' + encodeState();
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('shareBtn');
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = orig, 1500);
  }).catch(() => {
    prompt('Copy this URL:', url);
  });
}

// Override scheduleCompute to also update URL
const _origScheduleCompute = scheduleCompute;
function scheduleComputeWithURL() {
  if (computeTimeout) clearTimeout(computeTimeout);
  computeTimeout = setTimeout(() => {
    runCompute();
    updateURL();
  }, 150);
}
// Rebind
scheduleCompute = scheduleComputeWithURL;


// ═══════════════════════════════════════════════
// PRESETS — curated configurations demonstrating key findings
// ═══════════════════════════════════════════════

const PRESETS = [
  {
    name: 'Zero Paradox',
    desc: 'Fun = Winning (CPG≈0)',
    hash: 'combat,5,0.50,maxHp=5,heavyDmg=3,heavyHit=0.7,guardCounter=2,guardBlock=0.7',
  },
  {
    name: 'High Paradox',
    desc: 'Fun ≠ Winning (default)',
    hash: 'combat,5,0.50,maxHp=5,heavyDmg=2,heavyHit=0.5,guardCounter=1,guardBlock=0.5',
  },
  {
    name: 'Max Tension',
    desc: 'Ultra-high GDS (HP=7)',
    hash: 'asymmetric,7,0.50,hp=7',
  },
  {
    name: 'Best-of-7',
    desc: 'Classic series format',
    hash: 'bestofn,5,0.50,rounds=7',
  },
  {
    name: 'Quick Match',
    desc: 'HP=3 fast combat',
    hash: 'hp,5,0.50,hp=3',
  },
  {
    name: 'Deep Strategy',
    desc: 'High HP tactical',
    hash: 'combat,7,0.70,maxHp=7,heavyDmg=3,heavyHit=0.7,guardCounter=2,guardBlock=0.7',
  },
  {
    name: 'Coin Duel',
    desc: 'Resource wager game',
    hash: 'coinduel,5,0.50,roundsToWin=3,maxWager=3,initialBank=5,refill=1',
  },
  {
    name: 'Coin Duel+',
    desc: 'High agency variant',
    hash: 'coinduel,5,0.50,roundsToWin=3,maxWager=4,initialBank=5,refill=2',
  },
];

function buildPresetGrid() {
  const grid = document.getElementById('presetGrid');
  grid.innerHTML = '';
  for (const p of PRESETS) {
    const btn = document.createElement('button');
    btn.className = 'preset-btn';
    btn.innerHTML = `<span class="preset-name">${p.name}</span><span class="preset-desc">${p.desc}</span>`;
    btn.onclick = () => {
      decodeState(p.hash);
      scheduleCompute();
    };
    grid.appendChild(btn);
  }
}


// ═══════════════════════════════════════════════
// SNAPSHOT COMPARISON — before/after delta display
// ═══════════════════════════════════════════════

let snapshot = null;

function takeSnapshot() {
  // Capture current metric values
  const gds = parseFloat(document.getElementById('mGDS').textContent) || 0;
  const wgds = parseFloat(document.getElementById('mWGDS').textContent) || 0;
  const pi = parseFloat(document.getElementById('mPI').textContent) || 0;
  const cpg = parseFloat(document.getElementById('mCPG').textContent) || 0;
  const cfs = parseFloat(document.getElementById('mCFS').textContent) || 0;
  const enl = parseInt(document.getElementById('mENL').textContent) || 0;

  snapshot = { gds, wgds, pi, cpg, cfs, enl };

  document.getElementById('snapBtn').textContent = 'Update Snapshot';
  document.getElementById('clearSnapBtn').style.display = '';
  document.getElementById('snapLabel').textContent = 'Snapshot saved. Change parameters to compare.';
}

function clearSnapshot() {
  snapshot = null;
  document.getElementById('snapBtn').textContent = 'Snapshot';
  document.getElementById('clearSnapBtn').style.display = 'none';
  document.getElementById('snapLabel').textContent = 'Take a snapshot, then change parameters to see the difference.';

  // Remove all delta spans
  document.querySelectorAll('.delta').forEach(el => el.remove());
}

function showDeltas() {
  if (!snapshot) return;

  // Remove old deltas
  document.querySelectorAll('.delta').forEach(el => el.remove());

  const pairs = [
    ['mGDS', snapshot.gds, 3, true],
    ['mWGDS', snapshot.wgds, 3, true],
    ['mPI', snapshot.pi, 3, true],
    ['mCPG', snapshot.cpg, 3, false],  // lower CPG is better
    ['mCFS', snapshot.cfs, 3, true],
    ['mENL', snapshot.enl, 0, true],
  ];

  for (const [id, oldVal, dec, higherIsBetter] of pairs) {
    const el = document.getElementById(id);
    const newVal = parseFloat(el.textContent);
    if (isNaN(newVal) || el.textContent === '—') continue;

    const diff = newVal - oldVal;
    if (Math.abs(diff) < (dec > 0 ? 0.0005 : 0.5)) continue;

    const sign = diff > 0 ? '+' : '';
    const isGood = higherIsBetter ? diff > 0 : diff < 0;

    const span = document.createElement('span');
    span.className = `delta ${isGood ? 'up' : 'down'}`;
    span.textContent = `${sign}${diff.toFixed(dec)}`;
    el.parentElement.appendChild(span);
  }
}


// ═══════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════

buildPresetGrid();
if (!decodeState(window.location.hash)) {
  onGameChange();
} else {
  scheduleCompute();
}
</script>
</body>
</html>
