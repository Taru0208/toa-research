---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Draft Wars</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0c14;
  color: #c8ccd4;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  min-height: 100vh; overflow: hidden; user-select: none; touch-action: manipulation;
}
#gameContainer { position: relative; width: 640px; max-width: 100vw; }
canvas { display: block; width: 100%; height: auto; border-radius: 8px; }
#info { text-align: center; padding: 8px; font-size: 13px; color: #556; max-width: 640px; }
#stats { font-size: 12px; color: #445; padding: 4px; text-align: center; }
</style>
</head>
<body>
<div id="gameContainer"><canvas id="game" width="640" height="520"></canvas></div>
<div id="info">Click a card to draft it. Outsmart the AI by building the stronger hand.</div>
<div id="stats"></div>

<script>
'use strict';
const C = document.getElementById('game');
const ctx = C.getContext('2d');
const W = 640, H = 520;

// Audio
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
function playTone(f, d, t='sine', v=0.12) {
  ensureAudio();
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = t; o.frequency.value = f;
  g.gain.setValueAtTime(v, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + d);
  o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + d);
}
function sfxPick() { playTone(600 + Math.random()*200, 0.1, 'square', 0.08); }
function sfxAIPick() { playTone(400, 0.08, 'triangle', 0.06); }
function sfxHit() { playTone(200 + Math.random()*100, 0.15, 'sawtooth', 0.1); }
function sfxWin() { [523,659,784,1047].forEach((f,i)=>setTimeout(()=>playTone(f,0.2),i*100)); }
function sfxLose() { [400,350,300,250].forEach((f,i)=>setTimeout(()=>playTone(f,0.15,'sawtooth',0.06),i*120)); }

// Cards: name, attack, defense, color
const CARDS = [
  { name: 'Berserker', atk: 5, def: -1, color: '#ff4444', desc: 'High attack, fragile' },
  { name: 'Knight',    atk: 4, def: 0,  color: '#ffaa33', desc: 'Strong attacker' },
  { name: 'Warrior',   atk: 3, def: 1,  color: '#ff8844', desc: 'Balanced fighter' },
  { name: 'Ranger',    atk: 3, def: 0,  color: '#44cc44', desc: 'Light attacker' },
  { name: 'Guardian',  atk: 2, def: 2,  color: '#4488ff', desc: 'Tank' },
  { name: 'Fortress',  atk: 1, def: 3,  color: '#8866ff', desc: 'Defensive wall' },
];

// Game state
let phase = 'draft'; // draft, battle, result
let pool = []; // indices of available cards
let hand1 = []; // player's drafted cards (indices)
let hand2 = []; // AI's drafted cards
let turn = 0; // 0-5
let isPlayerTurn = true;
let battleStep = -1;
let battleTimer = 0;
let battleLog = [];
let hp1 = 0, hp2 = 0;
let particles = [];
let shakeTimer = 0;
let hoverCard = -1;

let stats = JSON.parse(localStorage.getItem('draftWarsStats') || '{"wins":0,"losses":0,"draws":0,"streak":0,"best":0}');
function saveStats() { localStorage.setItem('draftWarsStats', JSON.stringify(stats)); }

function resetGame() {
  pool = [0,1,2,3,4,5];
  hand1 = []; hand2 = [];
  turn = 0; isPlayerTurn = true;
  phase = 'draft';
  battleStep = -1; battleTimer = 0; battleLog = [];
  hp1 = 0; hp2 = 0;
  particles = []; shakeTimer = 0; hoverCard = -1;
}

// AI: picks card with highest attack that counters player's defense
function aiPick() {
  if (pool.length === 0) return;
  // Simple heuristic: pick highest attack from remaining, with slight preference for balance
  let best = -1, bestScore = -999;
  for (const idx of pool) {
    const c = CARDS[idx];
    let score = c.atk * 1.5 + c.def;
    // If player has high attack cards, prefer defense
    const playerAtk = hand1.reduce((s, i) => s + CARDS[i].atk, 0);
    if (playerAtk > 6) score += c.def * 0.5;
    // Slight randomness
    score += Math.random() * 0.5;
    if (score > bestScore) { bestScore = score; best = idx; }
  }
  if (best >= 0) {
    hand2.push(best);
    pool = pool.filter(i => i !== best);
    sfxAIPick();
  }
}

function pickCard(cardIdx) {
  if (phase !== 'draft' || !isPlayerTurn) return;
  if (!pool.includes(cardIdx)) return;
  ensureAudio();

  hand1.push(cardIdx);
  pool = pool.filter(i => i !== cardIdx);
  sfxPick();
  turn++;
  isPlayerTurn = false;

  if (turn >= 6) {
    startBattle();
    return;
  }

  // AI picks after short delay
  setTimeout(() => {
    aiPick();
    turn++;
    isPlayerTurn = true;
    if (turn >= 6) startBattle();
  }, 400);
}

function startBattle() {
  phase = 'battle';
  // Calculate totals
  const atk1 = hand1.reduce((s, i) => s + CARDS[i].atk, 0);
  const def1 = hand1.reduce((s, i) => s + CARDS[i].def, 0);
  const atk2 = hand2.reduce((s, i) => s + CARDS[i].atk, 0);
  const def2 = hand2.reduce((s, i) => s + CARDS[i].def, 0);

  hp1 = 10 + def1; // base HP + defense
  hp2 = 10 + def2;

  // Battle sequence: alternate attacks (hand order)
  battleLog = [];
  let h1 = hp1, h2 = hp2;
  for (let i = 0; i < 3; i++) {
    // Player attacks
    const pAtk = CARDS[hand1[i]].atk;
    h2 = Math.max(0, h2 - pAtk);
    battleLog.push({ attacker: 'P1', card: hand1[i], dmg: pAtk, hp1: h1, hp2: h2 });
    if (h2 <= 0) break;
    // AI attacks
    const aAtk = CARDS[hand2[i]].atk;
    h1 = Math.max(0, h1 - aAtk);
    battleLog.push({ attacker: 'P2', card: hand2[i], dmg: aAtk, hp1: h1, hp2: h2 });
    if (h1 <= 0) break;
  }
  battleStep = 0;
  battleTimer = 0;
}

function spawnParticles(x, y, color, count=10) {
  for (let i = 0; i < count; i++) {
    const a = Math.PI*2*i/count + Math.random()*0.5;
    particles.push({ x, y, vx: Math.cos(a)*(2+Math.random()*2), vy: Math.sin(a)*(2+Math.random()*2)-1, life:1, decay:0.02+Math.random()*0.01, size:2+Math.random()*3, color });
  }
}

// --- Rendering ---
function drawCard(x, y, cardIdx, w=80, h=110, selectable=false, selected=false, dimmed=false) {
  const c = CARDS[cardIdx];
  ctx.save();
  if (dimmed) ctx.globalAlpha = 0.3;

  // Card bg
  const isHover = selectable && hoverCard === cardIdx;
  ctx.fillStyle = isHover ? '#1e2235' : '#12151f';
  ctx.strokeStyle = selected ? '#f0d060' : (isHover ? '#556' : '#2a2d3a');
  ctx.lineWidth = selected ? 2 : 1;
  roundRect(x, y, w, h, 6);
  ctx.fill(); ctx.stroke();

  // Color bar
  ctx.fillStyle = c.color;
  ctx.fillRect(x+3, y+3, w-6, 4);

  // Name
  ctx.fillStyle = c.color;
  ctx.font = 'bold 11px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(c.name, x+w/2, y+22);

  // Stats
  ctx.font = 'bold 20px sans-serif';
  ctx.fillStyle = '#ff6644';
  ctx.fillText(c.atk, x+w/4, y+55);
  ctx.fillStyle = '#4488ff';
  ctx.fillText(c.def >= 0 ? c.def : c.def, x+3*w/4, y+55);

  // Labels
  ctx.font = '9px sans-serif';
  ctx.fillStyle = '#667';
  ctx.fillText('ATK', x+w/4, y+68);
  ctx.fillText('DEF', x+3*w/4, y+68);

  // Description
  ctx.font = '9px sans-serif';
  ctx.fillStyle = '#556';
  ctx.fillText(c.desc, x+w/2, y+85);

  ctx.restore();
  return { x, y, w, h, cardIdx };
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y); ctx.arcTo(x+w, y, x+w, y+r, r);
  ctx.lineTo(x+w, y+h-r); ctx.arcTo(x+w, y+h, x+w-r, y+h, r);
  ctx.lineTo(x+r, y+h); ctx.arcTo(x, y+h, x, y+h-r, r);
  ctx.lineTo(x, y+r); ctx.arcTo(x, y, x+r, y, r);
  ctx.closePath();
}

function drawHPBar(x, y, w, hp, maxHp, color, label) {
  ctx.fillStyle = '#556';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(label, x, y-4);

  ctx.fillStyle = '#151822';
  roundRect(x, y, w, 14, 3); ctx.fill();

  const ratio = Math.max(0, hp / maxHp);
  ctx.fillStyle = color;
  if (ratio > 0) { roundRect(x, y, w * ratio, 14, 3); ctx.fill(); }

  ctx.fillStyle = '#fff';
  ctx.font = 'bold 10px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${Math.max(0,hp)}/${maxHp}`, x+w/2, y+11);
}

let clickableCards = [];

function render() {
  let ox = 0, oy = 0;
  if (shakeTimer > 0) { ox = (Math.random()-0.5)*shakeTimer*1.5; oy = (Math.random()-0.5)*shakeTimer*1.5; shakeTimer--; }
  ctx.save();
  ctx.translate(ox, oy);

  ctx.fillStyle = '#0a0c14';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.fillStyle = '#8866ff';
  ctx.font = 'bold 20px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('DRAFT WARS', W/2, 28);

  clickableCards = [];

  if (phase === 'draft') {
    // Phase label
    ctx.fillStyle = '#889';
    ctx.font = '13px sans-serif';
    ctx.fillText(isPlayerTurn ? 'ðŸŸ¢ Your pick' : 'ðŸ”´ AI picking...', W/2, 50);

    // Pool
    ctx.fillStyle = '#556';
    ctx.font = '12px sans-serif';
    ctx.fillText('Available Cards', W/2, 72);

    const poolW = 88;
    const poolStartX = W/2 - (pool.length * poolW) / 2;
    pool.forEach((cardIdx, i) => {
      const cx = poolStartX + i * poolW + 4;
      const info = drawCard(cx, 80, cardIdx, 80, 110, isPlayerTurn);
      if (isPlayerTurn) clickableCards.push(info);
    });

    // Hands
    ctx.fillStyle = '#4488ff';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('YOUR HAND', 30, 220);

    hand1.forEach((cardIdx, i) => {
      drawCard(30 + i * 88, 230, cardIdx, 80, 110, false, true);
    });
    // Empty slots
    for (let i = hand1.length; i < 3; i++) {
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      roundRect(30 + i * 88, 230, 80, 110, 6); ctx.stroke();
      ctx.fillStyle = '#222'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('empty', 70 + i * 88, 290);
    }

    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('AI HAND', W-30, 220);

    hand2.forEach((cardIdx, i) => {
      drawCard(W - 30 - (i+1) * 88, 230, cardIdx, 80, 110);
    });
    for (let i = hand2.length; i < 3; i++) {
      ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
      roundRect(W - 30 - (i+1) * 88, 230, 80, 110, 6); ctx.stroke();
      ctx.fillStyle = '#222'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
      ctx.fillText('?', W - 30 - (i+1) * 88 + 40, 290);
    }

    // Draft summary
    if (hand1.length > 0) {
      const atk1 = hand1.reduce((s,i)=>s+CARDS[i].atk, 0);
      const def1 = hand1.reduce((s,i)=>s+CARDS[i].def, 0);
      ctx.fillStyle = '#667';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(`Total: ATK ${atk1}  DEF ${def1}  HP ${10+def1}`, 30, 360);
    }

  } else if (phase === 'battle' || phase === 'result') {
    // Show hands side by side
    ctx.fillStyle = '#4488ff'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('YOU', 160, 55);
    ctx.fillStyle = '#ff4444';
    ctx.fillText('AI', 480, 55);

    hand1.forEach((cardIdx, i) => {
      const highlight = battleStep >= 0 && battleLog[battleStep] && battleLog[battleStep].attacker === 'P1' && battleLog[battleStep].card === cardIdx;
      drawCard(70 + i * 70, 65, cardIdx, 60, 85, false, highlight);
    });
    hand2.forEach((cardIdx, i) => {
      const highlight = battleStep >= 0 && battleLog[battleStep] && battleLog[battleStep].attacker === 'P2' && battleLog[battleStep].card === cardIdx;
      drawCard(W - 280 + i * 70, 65, cardIdx, 60, 85, false, highlight);
    });

    // HP bars
    const maxHp1 = 10 + hand1.reduce((s,i)=>s+CARDS[i].def, 0);
    const maxHp2 = 10 + hand2.reduce((s,i)=>s+CARDS[i].def, 0);
    const curStep = Math.min(battleStep, battleLog.length - 1);
    const curHp1 = curStep >= 0 ? battleLog[curStep].hp1 : maxHp1;
    const curHp2 = curStep >= 0 ? battleLog[curStep].hp2 : maxHp2;

    drawHPBar(40, 170, 240, curHp1, maxHp1, '#4488ff', 'Your HP');
    drawHPBar(W-280, 170, 240, curHp2, maxHp2, '#ff4444', 'AI HP');

    // VS
    ctx.fillStyle = '#445';
    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('âš”', W/2, 135);

    // Battle log
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    for (let i = 0; i <= curStep && i < battleLog.length; i++) {
      const log = battleLog[i];
      const c = CARDS[log.card];
      const who = log.attacker === 'P1' ? 'You' : 'AI';
      ctx.fillStyle = log.attacker === 'P1' ? '#4488ff' : '#ff4444';
      ctx.fillText(`${who} â†’ ${c.name} deals ${log.dmg} damage!`, W/2, 210 + i * 22);
    }

    // Result
    if (phase === 'result') {
      const finalLog = battleLog[battleLog.length - 1];
      let msg = '', msgColor = '';
      if (finalLog.hp2 <= 0 && finalLog.hp1 > 0) { msg = 'YOU WIN!'; msgColor = '#f0d060'; }
      else if (finalLog.hp1 <= 0 && finalLog.hp2 > 0) { msg = 'YOU LOSE'; msgColor = '#ff4444'; }
      else if (finalLog.hp1 <= 0 && finalLog.hp2 <= 0) { msg = 'DRAW!'; msgColor = '#88aaff'; }
      else {
        // Time's up â€” compare remaining HP
        if (finalLog.hp1 > finalLog.hp2) { msg = 'YOU WIN!'; msgColor = '#f0d060'; }
        else if (finalLog.hp2 > finalLog.hp1) { msg = 'YOU LOSE'; msgColor = '#ff4444'; }
        else { msg = 'DRAW!'; msgColor = '#88aaff'; }
      }

      ctx.fillStyle = msgColor;
      ctx.font = 'bold 28px sans-serif';
      ctx.fillText(msg, W/2, 430);

      ctx.fillStyle = '#667';
      ctx.font = '13px sans-serif';
      ctx.fillText('Click anywhere to play again', W/2, 460);
    }
  }

  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
    ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size);
  });
  ctx.globalAlpha = 1;

  ctx.restore();
}

function update() {
  if (phase === 'battle') {
    battleTimer++;
    if (battleTimer % 40 === 0 && battleStep < battleLog.length - 1) {
      battleStep++;
      const log = battleLog[battleStep];
      sfxHit();
      shakeTimer = 5;
      const isP1 = log.attacker === 'P1';
      spawnParticles(isP1 ? 480 : 160, 135, isP1 ? '#ff4444' : '#4488ff', 6);
    }
    if (battleStep >= battleLog.length - 1 && battleTimer > (battleLog.length * 40 + 60)) {
      endBattle();
    }
  }

  particles = particles.filter(p => {
    p.x += p.vx; p.y += p.vy; p.vy += 0.04; p.life -= p.decay;
    return p.life > 0;
  });
}

function endBattle() {
  phase = 'result';
  const finalLog = battleLog[battleLog.length - 1];
  let won = false, draw = false;

  if (finalLog.hp2 <= 0 && finalLog.hp1 > 0) won = true;
  else if (finalLog.hp1 > 0 && finalLog.hp2 > 0) {
    if (finalLog.hp1 > finalLog.hp2) won = true;
    else if (finalLog.hp1 === finalLog.hp2) draw = true;
  } else if (finalLog.hp1 <= 0 && finalLog.hp2 <= 0) draw = true;

  if (won) {
    sfxWin(); stats.wins++; stats.streak++;
    if (stats.streak > stats.best) stats.best = stats.streak;
    spawnParticles(W/2, 400, '#f0d060', 20);
  } else if (draw) {
    stats.draws++;
  } else {
    sfxLose(); stats.losses++; stats.streak = 0;
  }
  saveStats();
}

// Input
C.addEventListener('mousemove', e => {
  const rect = C.getBoundingClientRect();
  const sx = W / rect.width;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sx;

  hoverCard = -1;
  for (const c of clickableCards) {
    if (mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {
      hoverCard = c.cardIdx;
      break;
    }
  }
  C.style.cursor = hoverCard >= 0 ? 'pointer' : 'default';
});

C.addEventListener('click', e => {
  const rect = C.getBoundingClientRect();
  const sx = W / rect.width;
  const mx = (e.clientX - rect.left) * sx;
  const my = (e.clientY - rect.top) * sx;

  if (phase === 'result') { resetGame(); return; }

  for (const c of clickableCards) {
    if (mx >= c.x && mx <= c.x + c.w && my >= c.y && my <= c.y + c.h) {
      pickCard(c.cardIdx);
      return;
    }
  }
});

function updateStatsUI() {
  document.getElementById('stats').textContent =
    `W:${stats.wins} L:${stats.losses} D:${stats.draws} | Streak:${stats.streak} Best:${stats.best}`;
}

function gameLoop() { update(); render(); updateStatsUI(); requestAnimationFrame(gameLoop); }

resetGame();
gameLoop();
</script>
</body>
</html>
