---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Design Lab — Before &amp; After</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #080a12;
  color: #c8ccd4;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
}
h1 { font-size: 22px; font-weight: 700; margin: 14px 0 2px; color: #e0e4ec; letter-spacing: -0.5px; }
.subtitle { font-size: 13px; color: #607090; margin-bottom: 10px; }

/* Tab selector */
.tab-bar {
  display: flex; gap: 2px; margin-bottom: 8px; background: #0c0e18; border-radius: 8px; padding: 3px;
  border: 1px solid #1a1e2e;
}
.tab {
  padding: 10px 28px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;
  color: #607090; transition: all 0.2s; position: relative;
}
.tab:hover { color: #8090a8; }
.tab.active-before {
  background: linear-gradient(180deg, #2a1520 0%, #1a0e14 100%);
  color: #d06060; border: 1px solid #502030;
}
.tab.active-after {
  background: linear-gradient(180deg, #152a20 0%, #0e1a14 100%);
  color: #50c070; border: 1px solid #205030;
}
.tab .tag {
  font-size: 9px; position: absolute; top: 3px; right: 6px;
  padding: 1px 5px; border-radius: 3px; font-weight: 700; letter-spacing: 0.5px;
}
.tab .tag-bad { background: #301520; color: #d06060; }
.tab .tag-good { background: #153020; color: #50c070; }

/* Game area */
#gameContainer { position: relative; width: 800px; max-width: 100vw; }
canvas { display: block; width: 100%; height: auto; border-radius: 8px; }

/* Controls */
#controls {
  display: flex; gap: 8px; padding: 8px 0; justify-content: center; flex-wrap: wrap;
  width: 100%; max-width: 800px;
}
.btn {
  background: linear-gradient(180deg, #1a1e2e 0%, #121520 100%);
  border: 1px solid #2a3050; color: #c8ccd4;
  padding: 10px 16px; border-radius: 8px; font-size: 14px; font-weight: 600;
  cursor: pointer; transition: all 0.15s; min-width: 120px; text-align: center;
}
.btn:hover:not(:disabled) {
  border-color: #4a5580; background: linear-gradient(180deg, #222840 0%, #181c2c 100%);
  transform: translateY(-1px);
}
.btn:active:not(:disabled) { transform: translateY(1px); }
.btn:disabled { opacity: 0.35; cursor: default; }
.btn-strike { border-color: #3060c0; }
.btn-strike:hover:not(:disabled) { border-color: #5080e0; box-shadow: 0 0 12px rgba(48,96,192,0.3); }
.btn-heavy { border-color: #c06030; }
.btn-heavy:hover:not(:disabled) { border-color: #e08050; box-shadow: 0 0 12px rgba(192,96,48,0.3); }
.btn-guard { border-color: #30c060; }
.btn-guard:hover:not(:disabled) { border-color: #50e080; box-shadow: 0 0 12px rgba(48,192,96,0.3); }
.btn-play {
  background: linear-gradient(180deg, #1a3060 0%, #102040 100%);
  border-color: #3070c0; font-size: 16px; padding: 12px 36px; min-width: 140px;
}
.btn-play:hover:not(:disabled) { border-color: #5090e0; box-shadow: 0 0 16px rgba(48,112,192,0.4); }
.btn-sub { font-size: 10px; color: #7080a0; display: block; margin-top: 2px; font-weight: 400; }

/* Log */
#log {
  width: 100%; max-width: 800px; height: 50px; overflow-y: auto;
  padding: 4px 10px; font-size: 12px; line-height: 1.5; color: #8090a8;
  background: #0c0e18; border-radius: 6px; border: 1px solid #1a1e2e;
}
#log::-webkit-scrollbar { width: 4px; }
#log::-webkit-scrollbar-track { background: transparent; }
#log::-webkit-scrollbar-thumb { background: #2a3050; border-radius: 2px; }
.log-player { color: #6090d0; }
.log-enemy { color: #d06060; }
.log-heavy { color: #e09050; font-weight: 600; }
.log-guard { color: #50c070; }
.log-miss { color: #606880; font-style: italic; }
.log-counter { color: #c060c0; }

/* Stats bar */
#stats-bar {
  display: flex; gap: 16px; padding: 4px 0; font-size: 12px; color: #506080;
  max-width: 800px; width: 100%; justify-content: center;
}
.stat-val { color: #8098c0; font-weight: 600; }

/* Comparison panel (bottom) */
#comparison {
  max-width: 800px; width: 100%; margin: 10px 0 20px;
  background: #0c0e18; border: 1px solid #1a2040; border-radius: 8px;
  padding: 14px 18px; font-size: 13px; line-height: 1.6; color: #8090a8;
}
#comparison h3 { font-size: 14px; color: #a0b0d0; margin-bottom: 8px; }
.cmp-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.cmp-col h4 {
  font-size: 11px; color: #607090; margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px;
}
.cmp-col.before h4 { color: #d06060; }
.cmp-col.after h4 { color: #50c070; }
.metric {
  display: inline-block; background: #141828; padding: 2px 7px; border-radius: 4px;
  font-family: 'Consolas', 'SF Mono', monospace; font-size: 12px; color: #a0b0d0;
}
.metric-bad { color: #d06060; border: 1px solid #301520; }
.metric-good { color: #50c070; border: 1px solid #153020; }
.highlight-bad { color: #d06060; font-weight: 600; }
.highlight-good { color: #50c070; font-weight: 600; }

/* Recommendation banner */
.rec-banner {
  margin-top: 8px; padding: 8px 12px; border-radius: 6px; font-size: 12px;
}
.rec-before {
  background: #1a0e14; border: 1px solid #402030; color: #c08090;
}
.rec-after {
  background: #0e1a14; border: 1px solid #204030; color: #80c090;
}

/* Win probability chart area in comparison */
.chart-area {
  margin-top: 10px; padding: 6px; background: #080a12; border-radius: 6px;
  border: 1px solid #1a1e2e;
}
.chart-label { font-size: 10px; color: #506080; margin-bottom: 2px; }

/* Stat highlight bars */
.bar-container {
  display: flex; align-items: center; gap: 8px; margin: 3px 0;
}
.bar-label { font-size: 11px; color: #607090; width: 80px; text-align: right; }
.bar-track { flex: 1; height: 14px; background: #141828; border-radius: 3px; overflow: hidden; position: relative; }
.bar-fill { height: 100%; border-radius: 3px; transition: width 0.3s ease; }
.bar-value { font-size: 10px; color: #a0b0d0; width: 50px; font-family: 'Consolas', 'SF Mono', monospace; }
</style>
</head>
<body>
<h1>Design Lab</h1>
<p class="subtitle">Same game, different parameters. Feel the difference.</p>

<div class="tab-bar">
  <div class="tab active-before" id="tabBefore" onclick="switchMode('before')">
    Before
    <span class="tag tag-bad">CPG 0.35</span>
  </div>
  <div class="tab" id="tabAfter" onclick="switchMode('after')">
    After
    <span class="tag tag-good">CPG 0.00</span>
  </div>
</div>

<div id="gameContainer">
  <canvas id="canvas" width="800" height="380"></canvas>
  <div id="controls"></div>
  <div id="log"></div>
  <div id="stats-bar">
    <span>Wins: <span class="stat-val" id="sWins">0</span></span>
    <span>Losses: <span class="stat-val" id="sLosses">0</span></span>
    <span>Heavy%: <span class="stat-val" id="sHeavy">-</span></span>
    <span>Win rate: <span class="stat-val" id="sWinRate">-</span></span>
  </div>
</div>

<div id="comparison">
  <h3>What changes between Before &amp; After?</h3>
  <div class="cmp-grid">
    <div class="cmp-col before">
      <h4>Before (Standard Design)</h4>
      <div>Heavy: <span class="metric">2 dmg @ 50%</span></div>
      <div>Guard counter: <span class="metric">1 dmg</span></div>
      <div>Guard vs heavy block: <span class="metric">50%</span></div>
      <div style="margin-top:8px">
        Winning strategy: <span class="highlight-bad">Guard spam</span><br>
        Fun strategy: Heavy attack<br>
        <strong>Fun ≠ Winning</strong> → <span class="metric metric-bad">CPG = 0.346</span>
      </div>
      <div class="rec-banner rec-before">
        To win, play Guard. But Guard is boring — you're just blocking.<br>
        The exciting Heavy attack loses more often. You must choose: fun or victory.
      </div>
    </div>
    <div class="cmp-col after">
      <h4>After (ToA-Optimized Design)</h4>
      <div>Heavy: <span class="metric">3 dmg @ 70%</span></div>
      <div>Guard counter: <span class="metric">2 dmg</span></div>
      <div>Guard vs heavy block: <span class="metric">70%</span></div>
      <div style="margin-top:8px">
        Winning strategy: <span class="highlight-good">Heavy attack</span><br>
        Fun strategy: Heavy attack<br>
        <strong>Fun = Winning</strong> → <span class="metric metric-good">CPG = 0.000</span>
      </div>
      <div class="rec-banner rec-after">
        Heavy does massive damage when it lands. Going aggressive IS the best play.<br>
        No paradox — the exciting choice is also the correct choice.
      </div>
    </div>
  </div>

  <div style="margin-top: 14px;">
    <h3>Your Play Data</h3>
    <div class="cmp-grid" id="play-data">
      <div class="cmp-col before">
        <h4>Before Stats</h4>
        <div class="bar-container">
          <span class="bar-label">Win rate</span>
          <div class="bar-track"><div class="bar-fill" id="bar-before-wr" style="width:0;background:#d06060"></div></div>
          <span class="bar-value" id="val-before-wr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Heavy%</span>
          <div class="bar-track"><div class="bar-fill" id="bar-before-hr" style="width:0;background:#e09050"></div></div>
          <span class="bar-value" id="val-before-hr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Games</span>
          <div class="bar-track"><div class="bar-fill" id="bar-before-gm" style="width:0;background:#5070a0"></div></div>
          <span class="bar-value" id="val-before-gm">0</span>
        </div>
      </div>
      <div class="cmp-col after">
        <h4>After Stats</h4>
        <div class="bar-container">
          <span class="bar-label">Win rate</span>
          <div class="bar-track"><div class="bar-fill" id="bar-after-wr" style="width:0;background:#50c070"></div></div>
          <span class="bar-value" id="val-after-wr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Heavy%</span>
          <div class="bar-track"><div class="bar-fill" id="bar-after-hr" style="width:0;background:#e09050"></div></div>
          <span class="bar-value" id="val-after-hr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Games</span>
          <div class="bar-track"><div class="bar-fill" id="bar-after-gm" style="width:0;background:#5070a0"></div></div>
          <span class="bar-value" id="val-after-gm">0</span>
        </div>
      </div>
    </div>
    <div id="verdict" style="margin-top:10px; padding:8px 12px; border-radius:6px; font-size:12px; background:#141828; color:#607090; text-align:center; display:none;">
    </div>
  </div>
</div>

<script>
// ============================================================
//  DESIGN LAB — Before/After CPG Comparison
// ============================================================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 800, H = 380;
const controlsEl = document.getElementById('controls');
const logEl = document.getElementById('log');

// === TWO CONFIGURATIONS ===
const CONFIGS = {
  before: {
    label: 'Standard Design',
    MAX_HP: 5,
    STRIKE_DMG: 1,
    HEAVY_DMG: 2,
    HEAVY_HIT: 0.50,
    GUARD_COUNTER: 1,
    GUARD_BLOCK: 0.50,
    accentColor: '#d06060',
    bgTint: [24, 12, 16],
  },
  after: {
    label: 'ToA-Optimized Design',
    MAX_HP: 5,
    STRIKE_DMG: 1,
    HEAVY_DMG: 3,
    HEAVY_HIT: 0.70,
    GUARD_COUNTER: 2,
    GUARD_BLOCK: 0.70,
    accentColor: '#50c070',
    bgTint: [12, 24, 16],
  }
};

let currentMode = 'before';
let cfg = CONFIGS.before;

// Per-mode stats
const modeStats = {
  before: { wins: 0, losses: 0, heavyCount: 0, totalActions: 0 },
  after: { wins: 0, losses: 0, heavyCount: 0, totalActions: 0 },
};
try {
  const saved = localStorage.getItem('designLab_stats');
  if (saved) Object.assign(modeStats, JSON.parse(saved));
} catch(e) {}
function saveStats() {
  try { localStorage.setItem('designLab_stats', JSON.stringify(modeStats)); } catch(e) {}
}

function switchMode(mode) {
  currentMode = mode;
  cfg = CONFIGS[mode];
  document.getElementById('tabBefore').className = mode === 'before' ? 'tab active-before' : 'tab';
  document.getElementById('tabAfter').className = mode === 'after' ? 'tab active-after' : 'tab';
  winProbCache = {};
  precomputeWinProb();
  gameState = 'title';
  updateButtons();
  updateComparisonBars();
}

// === AUDIO ===
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playSound(type) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const g = audioCtx.createGain();
  g.connect(audioCtx.destination);
  const o = audioCtx.createOscillator();
  o.connect(g);
  switch(type) {
    case 'hit':
      o.type = 'sawtooth'; o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.15);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      o.start(now); o.stop(now + 0.2); break;
    case 'heavy':
      o.type = 'sawtooth'; o.frequency.setValueAtTime(150, now);
      o.frequency.exponentialRampToValueAtTime(40, now + 0.3);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      o.start(now); o.stop(now + 0.35);
      const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
      o2.connect(g2); g2.connect(audioCtx.destination);
      o2.type = 'sine'; o2.frequency.setValueAtTime(60, now);
      g2.gain.setValueAtTime(0.15, now);
      g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      o2.start(now); o2.stop(now + 0.4); break;
    case 'miss':
      o.type = 'sine'; o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(150, now + 0.2);
      g.gain.setValueAtTime(0.06, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.start(now); o.stop(now + 0.25); break;
    case 'guard':
      o.type = 'triangle'; o.frequency.setValueAtTime(500, now);
      o.frequency.exponentialRampToValueAtTime(700, now + 0.1);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      o.start(now); o.stop(now + 0.15); break;
    case 'counter':
      o.type = 'square'; o.frequency.setValueAtTime(150, now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.25);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      o.start(now); o.stop(now + 0.3); break;
    case 'block':
      o.type = 'triangle'; o.frequency.setValueAtTime(600, now);
      o.frequency.exponentialRampToValueAtTime(300, now + 0.15);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      o.start(now); o.stop(now + 0.2); break;
    case 'win':
      o.type = 'triangle';
      [400,500,600,800].forEach((f,i) => o.frequency.setValueAtTime(f, now + i * 0.12));
      g.gain.setValueAtTime(0.1, now);
      g.gain.setValueAtTime(0.1, now + 0.45);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
      o.start(now); o.stop(now + 0.7); break;
    case 'lose':
      o.type = 'sawtooth'; o.frequency.setValueAtTime(250, now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.6);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
      o.start(now); o.stop(now + 0.7); break;
    case 'select':
      o.type = 'sine'; o.frequency.setValueAtTime(600, now);
      o.frequency.exponentialRampToValueAtTime(800, now + 0.06);
      g.gain.setValueAtTime(0.05, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      o.start(now); o.stop(now + 0.08); break;
  }
}

// === PARTICLES ===
const particles = [];
function spawnParticles(x, y, color, count, speed, life, size) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = (Math.random() * 0.6 + 0.4) * speed;
    particles.push({
      x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd - Math.random() * 1.5,
      life: life * (0.7 + Math.random() * 0.6), maxLife: life * (0.7 + Math.random() * 0.6),
      color, size: size * (0.5 + Math.random() * 0.5), gravity: 0.08
    });
  }
}
function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt; p.vy += p.gravity * dt; p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}
function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life / p.maxLife) * 0.9;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (p.life / p.maxLife), 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// === FLOATING TEXT ===
const floatingTexts = [];
function spawnFloat(x, y, text, color, size) {
  floatingTexts.push({ x, y, text, color, size: size || 20, life: 50, maxLife: 50, vy: -1.5 });
}
function updateFloats(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y += t.vy * dt; t.vy *= 0.98; t.life -= dt;
    if (t.life <= 0) floatingTexts.splice(i, 1);
  }
}
function drawFloats() {
  for (const t of floatingTexts) {
    const a = Math.max(0, t.life / t.maxLife);
    const s = 1 + (1 - a) * 0.3;
    ctx.save(); ctx.globalAlpha = a;
    ctx.font = `bold ${Math.round(t.size * s)}px 'Segoe UI', system-ui, sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#000'; ctx.fillText(t.text, t.x + 2, t.y + 2);
    ctx.fillStyle = t.color; ctx.fillText(t.text, t.x, t.y);
    ctx.restore();
  }
}

// === SCREEN SHAKE ===
let shakeAmt = 0, shakeDur = 0;
function shake(a, d) { shakeAmt = a; shakeDur = d; }
function shakeOff() {
  if (shakeDur <= 0) return { x: 0, y: 0 };
  const i = shakeDur / 20 * shakeAmt;
  return { x: (Math.random() - 0.5) * i * 2, y: (Math.random() - 0.5) * i * 2 };
}

// === FIGHTER ===
class FighterAnim {
  constructor(bx, by) {
    this.bx = bx; this.by = by; this.x = bx; this.y = by;
    this.hf = 0; this.bp = Math.random() * Math.PI * 2;
    this.atk = false; this.ax = 0; this.ap = 0;
  }
  update(dt) {
    this.bp += 0.03 * dt; this.y = this.by + Math.sin(this.bp) * 2;
    if (this.hf > 0) this.hf -= 0.03 * dt;
    if (this.atk) {
      this.ap += 0.06 * dt;
      if (this.ap < 1) this.x = this.bx + this.ax * Math.sin(this.ap * Math.PI);
      else { this.atk = false; this.ap = 0; this.x = this.bx; }
    }
  }
  attack(tx) { this.atk = true; this.ap = 0; this.ax = (tx - this.bx) * 0.4; }
  flash() { this.hf = 1; }
}

function drawFighter(x, y, color, hp, maxHp, guarding, faceLeft, hitFlash, name) {
  ctx.save();
  const fl = hitFlash > 0 ? `rgba(255,255,255,${hitFlash * 0.6})` : null;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(x, y + 48, 22, 6, 0, 0, Math.PI * 2); ctx.fill();

  // Guard shield
  if (guarding) {
    ctx.strokeStyle = '#50e080'; ctx.lineWidth = 2.5;
    ctx.globalAlpha = 0.4 + Math.sin(Date.now() * 0.006) * 0.15;
    ctx.beginPath(); ctx.ellipse(x, y - 10, 35, 50, 0, 0, Math.PI * 2); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  const d = faceLeft ? -1 : 1;

  // Legs
  ctx.strokeStyle = fl || color; ctx.lineWidth = 4; ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x - 6, y + 20); ctx.lineTo(x - 10, y + 45);
  ctx.moveTo(x + 6, y + 20); ctx.lineTo(x + 10, y + 45);
  ctx.stroke();

  // Body
  ctx.fillStyle = fl || color;
  ctx.beginPath(); ctx.roundRect(x - 12, y - 15, 24, 38, 4); ctx.fill();

  // Arms
  ctx.strokeStyle = fl || color; ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x - 12 * d, y - 5); ctx.lineTo(x - 22 * d, y + 10);
  ctx.moveTo(x + 12 * d, y - 5); ctx.lineTo(x + 22 * d, y + 5);
  ctx.stroke();

  // Head
  ctx.fillStyle = fl || color;
  ctx.beginPath(); ctx.arc(x, y - 28, 14, 0, Math.PI * 2); ctx.fill();

  // Eyes
  const ex = faceLeft ? -4 : 4;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x + ex - 3, y - 30, 3, 0, Math.PI * 2);
  ctx.arc(x + ex + 5, y - 30, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(x + ex - 3 + (faceLeft ? -0.5 : 0.5), y - 30, 1.5, 0, Math.PI * 2);
  ctx.arc(x + ex + 5 + (faceLeft ? -0.5 : 0.5), y - 30, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // HP Bar
  const bw = 60, bh = 7, bx = x - bw/2, by = y - 55;
  ctx.fillStyle = '#1a1020'; ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
  const r = Math.max(0, hp / maxHp);
  ctx.fillStyle = r > 0.5 ? '#40c070' : r > 0.25 ? '#d0a030' : '#d04040';
  ctx.fillRect(bx, by, bw * r, bh);

  // Name
  ctx.font = 'bold 12px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center'; ctx.fillStyle = '#506080';
  ctx.fillText(name, x, by - 6);

  // HP text
  ctx.font = '11px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#8090a8';
  ctx.fillText(`${hp}/${maxHp}`, x, by + bh + 14);

  ctx.restore();
}

// === WIN PROBABILITY (DP) ===
let winProbCache = {};
function computeWinProb(ph, eh) {
  const key = `${ph},${eh}`;
  if (winProbCache[key] !== undefined) return winProbCache[key];
  if (ph <= 0 && eh <= 0) { winProbCache[key] = 0.5; return 0.5; }
  if (ph <= 0) { winProbCache[key] = 0; return 0; }
  if (eh <= 0) { winProbCache[key] = 1; return 1; }
  winProbCache[key] = 0.5;

  const hh = cfg.HEAVY_HIT, gb = cfg.GUARD_BLOCK;
  const hd = cfg.HEAVY_DMG, sd = cfg.STRIKE_DMG, gc = cfg.GUARD_COUNTER;
  let nls = 0, slw = 0;

  // Strike vs Strike
  nls += computeWinProb(ph - sd, eh - sd);
  // Strike vs Heavy
  nls += hh * computeWinProb(ph - hd, eh) + (1-hh) * computeWinProb(ph, eh - gc);
  // Strike vs Guard: blocked → no change
  slw += 1;
  // Heavy vs Strike
  nls += hh * computeWinProb(ph, eh - hd) + (1-hh) * computeWinProb(ph - gc, eh);
  // Heavy vs Heavy
  nls += hh*hh * computeWinProb(ph - hd, eh - hd) +
         hh*(1-hh) * computeWinProb(ph, eh - hd) +
         (1-hh)*hh * computeWinProb(ph - hd, eh);
  slw += (1-hh)*(1-hh);
  // Heavy vs Guard
  slw += gb;
  nls += (1-gb) * hh * computeWinProb(ph, eh - hd);
  slw += (1-gb) * (1-hh);
  // Guard vs Strike: blocked
  slw += 1;
  // Guard vs Heavy
  slw += gb;
  nls += (1-gb) * hh * computeWinProb(ph - hd, eh);
  slw += (1-gb) * (1-hh);
  // Guard vs Guard
  slw += 1;

  const result = nls / (9 - slw);
  winProbCache[key] = result;
  return result;
}

function precomputeWinProb() {
  winProbCache = {};
  for (let t = 0; t <= cfg.MAX_HP * 2; t++) {
    for (let p = 0; p <= Math.min(t, cfg.MAX_HP); p++) {
      const e = t - p;
      if (e >= 0 && e <= cfg.MAX_HP) {
        delete winProbCache[`${p},${e}`];
        computeWinProb(p, e);
      }
    }
  }
}
precomputeWinProb();

// === GAME STATE ===
let gameState = 'title';
let player = { hp: cfg.MAX_HP, guarding: false };
let enemy = { hp: cfg.MAX_HP, guarding: false };
let pAnim, eAnim;
let turnQueue = [], animTimer = 0, canAct = false, turnCount = 0, titlePulse = 0;
let wpHistory = [];

function resetBattle() {
  player = { hp: cfg.MAX_HP, guarding: false };
  enemy = { hp: cfg.MAX_HP, guarding: false };
  pAnim = new FighterAnim(230, 220);
  eAnim = new FighterAnim(570, 220);
  turnQueue = []; animTimer = 0; canAct = true; turnCount = 0;
  logEl.innerHTML = '';
  gameState = 'battle';
  wpHistory = [0.5];
  updateButtons();
}

function addLog(html) {
  const d = document.createElement('div'); d.innerHTML = html;
  logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight;
}

// === AI ===
function aiDecide() {
  // AI plays roughly uniform — not optimized, so player can test their own strategy
  const w = { strike: 30, heavy: 35, guard: 35 };
  if (enemy.hp <= 2) { w.heavy = 50; w.guard = 15; }
  if (player.hp <= 2) { w.heavy = 45; w.strike = 35; }
  const total = w.strike + w.heavy + w.guard;
  let r = Math.random() * total;
  if (r < w.strike) return 'strike';
  r -= w.strike;
  if (r < w.heavy) return 'heavy';
  return 'guard';
}

// === COMBAT ===
function resolveAction(action, oppAction, isPlayer) {
  const name = isPlayer ? 'You' : 'CPU';
  const def = isPlayer ? 'CPU' : 'You';
  const events = [];
  let dmgOpp = 0, dmgSelf = 0;

  if (action === 'guard') {
    events.push({ type: 'guard', isPlayer, log: `<span class="log-guard">${name} raised guard.</span>` });
    return { dmgOpp, dmgSelf, events };
  }

  if (action === 'strike') {
    if (oppAction === 'guard') {
      events.push({ type: 'blocked', isPlayer, log: `<span class="log-miss">${name}'s strike was blocked.</span>` });
    } else {
      dmgOpp = cfg.STRIKE_DMG;
      events.push({ type: 'hit', isPlayer, dmg: cfg.STRIKE_DMG, log: `<span class="log-player">${name} struck for ${cfg.STRIKE_DMG}.</span>` });
    }
    return { dmgOpp, dmgSelf, events };
  }

  if (action === 'heavy') {
    if (oppAction === 'guard' && Math.random() < cfg.GUARD_BLOCK) {
      events.push({ type: 'blocked', isPlayer, log: `<span class="log-guard">${def} blocked the heavy!</span>` });
      return { dmgOpp, dmgSelf, events };
    }
    if (Math.random() < cfg.HEAVY_HIT) {
      dmgOpp = cfg.HEAVY_DMG;
      events.push({ type: 'heavy_hit', isPlayer, dmg: cfg.HEAVY_DMG, log: `<span class="log-heavy">${name} lands heavy — ${cfg.HEAVY_DMG} damage!</span>` });
    } else {
      dmgSelf = cfg.GUARD_COUNTER;
      events.push({ type: 'miss', isPlayer, log: `<span class="log-miss">${name}'s heavy missed!</span>` });
      events.push({ type: 'counter', isPlayer: !isPlayer, dmg: cfg.GUARD_COUNTER, log: `<span class="log-counter">${def} countered for ${cfg.GUARD_COUNTER}!</span>` });
    }
    return { dmgOpp, dmgSelf, events };
  }
  return { dmgOpp, dmgSelf, events };
}

function resolveTurn(pAction, eAction) {
  turnCount++;
  player.guarding = false; enemy.guarding = false;
  const pR = resolveAction(pAction, eAction, true);
  const eR = resolveAction(eAction, pAction, false);
  enemy.hp = Math.max(0, enemy.hp - pR.dmgOpp);
  player.hp = Math.max(0, player.hp - pR.dmgSelf);
  player.hp = Math.max(0, player.hp - eR.dmgOpp);
  enemy.hp = Math.max(0, enemy.hp - eR.dmgSelf);
  if (pAction === 'guard') player.guarding = true;
  if (eAction === 'guard') enemy.guarding = true;
  const events = [...pR.events, ...eR.events];
  wpHistory.push(computeWinProb(player.hp, enemy.hp));
  if (player.hp <= 0 || enemy.hp <= 0) {
    if (player.hp <= 0 && enemy.hp <= 0) events.push({ type: 'draw', log: 'Draw!' });
    else if (enemy.hp <= 0) events.push({ type: 'win', log: '<span class="log-player">Victory!</span>' });
    else events.push({ type: 'lose', log: '<span class="log-enemy">Defeat!</span>' });
  }
  return events;
}

function executeTurn(pAction) {
  if (!canAct || gameState !== 'battle') return;
  ensureAudio(); playSound('select'); canAct = false;
  const st = modeStats[currentMode];
  st.totalActions++;
  if (pAction === 'heavy') st.heavyCount++;
  saveStats();
  const eAction = aiDecide();
  turnQueue = resolveTurn(pAction, eAction);
  gameState = 'animating'; animTimer = 0;
  processEvent();
}

function processEvent() {
  if (turnQueue.length === 0) {
    if (player.hp <= 0 || enemy.hp <= 0) {
      gameState = 'gameover';
      const st = modeStats[currentMode];
      if (enemy.hp <= 0 && player.hp > 0) { st.wins++; playSound('win'); }
      else if (player.hp <= 0 && enemy.hp > 0) { st.losses++; playSound('lose'); }
      saveStats(); updateComparisonBars();
    } else { gameState = 'battle'; canAct = true; }
    updateButtons(); return;
  }
  const ev = turnQueue.shift(); animTimer = 0;
  addLog(ev.log);
  const px = pAnim.x, py = pAnim.y, ex = eAnim.x, ey = eAnim.y;
  switch(ev.type) {
    case 'hit':
      if (ev.isPlayer) {
        pAnim.attack(ex);
        setTimeout(() => { eAnim.flash(); spawnParticles(ex, ey-10, '#6090d0', 8, 3, 25, 3); spawnFloat(ex, ey-60, `-${cfg.STRIKE_DMG}`, '#6090d0'); playSound('hit'); shake(3,8); }, 200);
      } else {
        eAnim.attack(px);
        setTimeout(() => { pAnim.flash(); spawnParticles(px, py-10, '#d06060', 8, 3, 25, 3); spawnFloat(px, py-60, `-${cfg.STRIKE_DMG}`, '#d06060'); playSound('hit'); shake(3,8); }, 200);
      }
      setTimeout(processEvent, 500); break;
    case 'heavy_hit':
      if (ev.isPlayer) {
        pAnim.attack(ex);
        setTimeout(() => { eAnim.flash(); spawnParticles(ex, ey-10, '#e09050', 18, 5, 35, 4); spawnFloat(ex, ey-60, `-${cfg.HEAVY_DMG}`, '#e09050', 26); playSound('heavy'); shake(6,15); }, 200);
      } else {
        eAnim.attack(px);
        setTimeout(() => { pAnim.flash(); spawnParticles(px, py-10, '#e09050', 18, 5, 35, 4); spawnFloat(px, py-60, `-${cfg.HEAVY_DMG}`, '#e09050', 26); playSound('heavy'); shake(6,15); }, 200);
      }
      setTimeout(processEvent, 600); break;
    case 'miss': playSound('miss'); setTimeout(processEvent, 300); break;
    case 'counter':
      if (ev.isPlayer) {
        spawnParticles(ex, ey-10, '#c060c0', 12, 4, 30, 3);
        spawnFloat(ex, ey-60, `-${cfg.GUARD_COUNTER}`, '#c060c0'); eAnim.flash(); playSound('counter'); shake(4,10);
      } else {
        spawnParticles(px, py-10, '#c060c0', 12, 4, 30, 3);
        spawnFloat(px, py-60, `-${cfg.GUARD_COUNTER}`, '#c060c0'); pAnim.flash(); playSound('counter'); shake(4,10);
      }
      setTimeout(processEvent, 500); break;
    case 'blocked':
      playSound('block');
      const bx = ev.isPlayer ? ex : px, by = ev.isPlayer ? ey : py;
      spawnParticles(bx, by-10, '#50e080', 6, 2, 20, 2);
      spawnFloat(bx, by-60, 'BLOCKED', '#50e080', 16);
      setTimeout(processEvent, 400); break;
    case 'guard': playSound('guard'); setTimeout(processEvent, 250); break;
    default: setTimeout(processEvent, 100); break;
  }
}

// === BUTTONS ===
function updateButtons() {
  controlsEl.innerHTML = '';
  if (gameState === 'title') {
    const btn = document.createElement('button');
    btn.className = 'btn btn-play';
    btn.textContent = 'FIGHT';
    btn.onclick = () => { ensureAudio(); resetBattle(); };
    controlsEl.appendChild(btn);
  } else if (gameState === 'battle' && canAct) {
    const actions = [
      { id: 'strike', label: 'Strike', sub: `${cfg.STRIKE_DMG} dmg (reliable)`, cls: 'btn-strike', key: 'Q' },
      { id: 'heavy', label: 'Heavy', sub: `${cfg.HEAVY_DMG} dmg @ ${Math.round(cfg.HEAVY_HIT*100)}%`, cls: 'btn-heavy', key: 'W' },
      { id: 'guard', label: 'Guard', sub: `block / counter ${cfg.GUARD_COUNTER}`, cls: 'btn-guard', key: 'E' },
    ];
    actions.forEach(a => {
      const btn = document.createElement('button');
      btn.className = `btn ${a.cls}`;
      btn.innerHTML = `${a.label} <span class="btn-sub">${a.sub} [${a.key}]</span>`;
      btn.onclick = () => executeTurn(a.id);
      controlsEl.appendChild(btn);
    });
  } else if (gameState === 'gameover') {
    const btn = document.createElement('button');
    btn.className = 'btn btn-play';
    btn.textContent = 'FIGHT AGAIN';
    btn.onclick = () => { ensureAudio(); resetBattle(); };
    controlsEl.appendChild(btn);
  }
}

// === KEYBOARD ===
document.addEventListener('keydown', e => {
  if (gameState === 'battle' && canAct) {
    if (e.key === 'q' || e.key === 'Q') executeTurn('strike');
    else if (e.key === 'w' || e.key === 'W') executeTurn('heavy');
    else if (e.key === 'e' || e.key === 'E') executeTurn('guard');
  } else if (gameState === 'title' || gameState === 'gameover') {
    if (e.key === ' ' || e.key === 'Enter') { ensureAudio(); resetBattle(); }
  }
  // Tab switching with 1/2
  if (e.key === '1') switchMode('before');
  if (e.key === '2') switchMode('after');
});

// === WIN PROB CHART ===
function drawWPChart(x, y, w, h) {
  if (wpHistory.length < 1) return;
  ctx.save();
  ctx.fillStyle = 'rgba(10, 12, 24, 0.85)';
  ctx.beginPath(); ctx.roundRect(x-4, y-18, w+8, h+28, 6); ctx.fill();
  ctx.strokeStyle = '#1a2040'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(x-4, y-18, w+8, h+28, 6); ctx.stroke();
  ctx.font = '10px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#506080'; ctx.textAlign = 'left';
  ctx.fillText('Win Probability', x, y - 6);
  const cp = wpHistory[wpHistory.length - 1];
  ctx.textAlign = 'right';
  ctx.fillStyle = cp > 0.5 ? '#50c070' : cp < 0.5 ? '#d06060' : '#8090a8';
  ctx.font = 'bold 10px "Segoe UI", system-ui, sans-serif';
  ctx.fillText(`${(cp * 100).toFixed(0)}%`, x + w, y - 6);
  ctx.strokeStyle = '#2a3050'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
  ctx.beginPath(); ctx.moveTo(x, y + h/2); ctx.lineTo(x + w, y + h/2); ctx.stroke();
  ctx.setLineDash([]);
  if (wpHistory.length >= 2) {
    const step = w / Math.max(1, wpHistory.length - 1);
    ctx.beginPath();
    for (let i = 0; i < wpHistory.length; i++) {
      const px2 = x + i * step, py2 = y + h - wpHistory[i] * h;
      if (i === 0) ctx.moveTo(px2, py2); else ctx.lineTo(px2, py2);
    }
    ctx.strokeStyle = cfg.accentColor; ctx.lineWidth = 2; ctx.stroke();
    ctx.lineTo(x + (wpHistory.length - 1) * step, y + h);
    ctx.lineTo(x, y + h); ctx.closePath();
    const grad = ctx.createLinearGradient(0, y, 0, y + h);
    grad.addColorStop(0, cfg.accentColor.replace(')', ',0.15)').replace('rgb', 'rgba'));
    grad.addColorStop(1, 'rgba(80,128,192,0.02)');
    ctx.fillStyle = grad; ctx.fill();
  }
  if (wpHistory.length > 0) {
    const lx = x + (wpHistory.length - 1) * (w / Math.max(1, wpHistory.length - 1));
    const ly = y + h - cp * h;
    ctx.fillStyle = cfg.accentColor;
    ctx.beginPath(); ctx.arc(lx, ly, 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#c0d0e0';
    ctx.beginPath(); ctx.arc(lx, ly, 2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

// === MODE INDICATOR ===
function drawModeIndicator() {
  const label = currentMode === 'before' ? 'BEFORE' : 'AFTER';
  const sub = currentMode === 'before' ? 'Standard Design — CPG = 0.346' : 'ToA-Optimized — CPG = 0.000';
  const color = cfg.accentColor;

  ctx.save();
  ctx.font = 'bold 13px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = color;
  ctx.fillText(label, 16, 24);
  ctx.font = '10px "Segoe UI", system-ui, sans-serif';
  ctx.fillStyle = '#506080';
  ctx.fillText(sub, 16, 38);

  // Param box
  ctx.font = '9px "Consolas", "SF Mono", monospace';
  ctx.fillStyle = '#405060';
  ctx.fillText(`Heavy: ${cfg.HEAVY_DMG}dmg @${Math.round(cfg.HEAVY_HIT*100)}%  Guard: block ${Math.round(cfg.GUARD_BLOCK*100)}% + counter ${cfg.GUARD_COUNTER}`, 16, 52);
  ctx.restore();
}

// === DRAW ===
function draw() {
  ctx.clearRect(0, 0, W, H);
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, `rgb(${cfg.bgTint[0]}, ${cfg.bgTint[1]}, ${cfg.bgTint[2]})`);
  bg.addColorStop(1, '#080a12');
  ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);

  // Floor
  ctx.fillStyle = '#0e1020'; ctx.fillRect(0, 290, W, 90);
  ctx.strokeStyle = '#1a1e30'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, 290); ctx.lineTo(W, 290); ctx.stroke();

  drawModeIndicator();

  if (gameState === 'title') {
    titlePulse += 0.03;
    ctx.font = 'bold 30px "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center'; ctx.fillStyle = '#c0d0e8';
    ctx.fillText('Design Lab', W/2, 140);
    ctx.font = '15px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#607090';
    ctx.fillText('Same rules, different numbers. Feel the difference.', W/2, 170);
    ctx.font = '13px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#405070';
    const paramText = currentMode === 'before'
      ? 'Before: Heavy 2dmg@50%, Guard counter 1, Block 50%'
      : 'After: Heavy 3dmg@70%, Guard counter 2, Block 70%';
    ctx.fillText(paramText, W/2, 200);

    const a = 0.5 + Math.sin(titlePulse) * 0.3;
    ctx.globalAlpha = a;
    ctx.font = '14px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = cfg.accentColor;
    ctx.fillText('Press SPACE or click FIGHT', W/2, 250);
    ctx.globalAlpha = 1;

    ctx.font = '11px "Segoe UI", system-ui, sans-serif';
    ctx.fillStyle = '#354060';
    ctx.fillText('Press [1] for Before, [2] for After', W/2, 280);

    updateStatsDisplay(); return;
  }

  const s = shakeOff();
  ctx.save(); ctx.translate(s.x, s.y);
  drawFighter(pAnim.x, pAnim.y, '#4080c0', player.hp, cfg.MAX_HP, player.guarding, false, pAnim.hf, 'YOU');
  drawFighter(eAnim.x, eAnim.y, '#c04040', enemy.hp, cfg.MAX_HP, enemy.guarding, true, eAnim.hf, 'CPU');
  drawParticles(); drawFloats();
  ctx.restore();

  drawWPChart(305, 20, 180, 55);

  ctx.font = '11px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center'; ctx.fillStyle = '#304060';
  ctx.fillText(`Turn ${turnCount}`, W/2, H - 6);

  if (gameState === 'gameover') {
    ctx.font = 'bold 30px "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    if (player.hp <= 0 && enemy.hp <= 0) { ctx.fillStyle = '#8090a8'; ctx.fillText('DRAW', W/2, 165); }
    else if (enemy.hp <= 0) { ctx.fillStyle = '#50c070'; ctx.fillText('VICTORY', W/2, 165); }
    else { ctx.fillStyle = '#d06060'; ctx.fillText('DEFEAT', W/2, 165); }
  }
  updateStatsDisplay();
}

function updateStatsDisplay() {
  const st = modeStats[currentMode];
  document.getElementById('sWins').textContent = st.wins;
  document.getElementById('sLosses').textContent = st.losses;
  const hr = st.totalActions > 0 ? Math.round(st.heavyCount / st.totalActions * 100) + '%' : '-';
  document.getElementById('sHeavy').textContent = hr;
  const total = st.wins + st.losses;
  const wr = total > 0 ? Math.round(st.wins / total * 100) + '%' : '-';
  document.getElementById('sWinRate').textContent = wr;
}

// === COMPARISON BARS ===
function updateComparisonBars() {
  for (const mode of ['before', 'after']) {
    const st = modeStats[mode];
    const total = st.wins + st.losses;
    const wr = total > 0 ? st.wins / total * 100 : 0;
    const hr = st.totalActions > 0 ? st.heavyCount / st.totalActions * 100 : 0;

    document.getElementById(`bar-${mode}-wr`).style.width = wr + '%';
    document.getElementById(`val-${mode}-wr`).textContent = total > 0 ? wr.toFixed(0) + '%' : '-';
    document.getElementById(`bar-${mode}-hr`).style.width = hr + '%';
    document.getElementById(`val-${mode}-hr`).textContent = st.totalActions > 0 ? hr.toFixed(0) + '%' : '-';
    const maxGames = Math.max(
      modeStats.before.wins + modeStats.before.losses,
      modeStats.after.wins + modeStats.after.losses, 1
    );
    document.getElementById(`bar-${mode}-gm`).style.width = (total / maxGames * 100) + '%';
    document.getElementById(`val-${mode}-gm`).textContent = total;
  }

  // Verdict
  const bTotal = modeStats.before.wins + modeStats.before.losses;
  const aTotal = modeStats.after.wins + modeStats.after.losses;
  const verdict = document.getElementById('verdict');

  if (bTotal >= 3 && aTotal >= 3) {
    const bWR = modeStats.before.wins / bTotal;
    const aWR = modeStats.after.wins / aTotal;
    const bHR = modeStats.before.totalActions > 0 ? modeStats.before.heavyCount / modeStats.before.totalActions : 0;
    const aHR = modeStats.after.totalActions > 0 ? modeStats.after.heavyCount / modeStats.after.totalActions : 0;

    let msg = '';
    if (aHR > bHR + 0.05 && aWR > bWR - 0.1) {
      msg = 'You played more aggressively in After — and it worked! The optimized design rewards bold play.';
      verdict.style.borderColor = '#205030';
      verdict.style.color = '#80c090';
    } else if (aHR > bHR + 0.05 && aWR < bWR - 0.1) {
      msg = 'You went aggressive in After but won less. Try a few more games — the math says Heavy is optimal here.';
      verdict.style.borderColor = '#503020';
      verdict.style.color = '#c09080';
    } else if (bHR > 0.5 && bWR < 0.4) {
      msg = 'In Before, Heavy play leads to losses — that\'s the Choice Paradox. Guard wins but is boring.';
      verdict.style.borderColor = '#402030';
      verdict.style.color = '#c08090';
    } else {
      msg = `Before: ${(bWR*100).toFixed(0)}% win rate with ${(bHR*100).toFixed(0)}% Heavy. After: ${(aWR*100).toFixed(0)}% win rate with ${(aHR*100).toFixed(0)}% Heavy. Play more to see the pattern emerge.`;
      verdict.style.borderColor = '#1a2040';
      verdict.style.color = '#8090a8';
    }
    verdict.textContent = msg;
    verdict.style.display = 'block';
  } else {
    const needed = Math.max(0, 3 - bTotal) + Math.max(0, 3 - aTotal);
    verdict.textContent = `Play at least 3 games in each mode to see the comparison. (${needed} more needed)`;
    verdict.style.display = 'block';
    verdict.style.borderColor = '#1a2040';
    verdict.style.color = '#506080';
  }
}

// === MAIN LOOP ===
let lastTime = 0;
function loop(ts) {
  const dt = Math.min(3, (ts - lastTime) / 16.67);
  lastTime = ts;
  if (shakeDur > 0) shakeDur -= dt;
  updateParticles(dt); updateFloats(dt);
  if (pAnim) pAnim.update(dt);
  if (eAnim) eAnim.update(dt);
  draw();
  requestAnimationFrame(loop);
}
updateButtons();
updateComparisonBars();
requestAnimationFrame(loop);
</script>
</body>
</html>
