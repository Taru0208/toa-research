---
layout: null
---
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Design Lab — Can Math Make Games More Fun?</title>
<meta name="description" content="Play two versions of the same combat game and feel the difference. An interactive before/after demo showing how mathematical game design improves player experience.">
<meta property="og:title" content="Design Lab — Can Math Make Games More Fun?">
<meta property="og:description" content="Play two versions of the same combat game and feel the difference. Interactive before/after demo of Anticipation Theory.">
<meta property="og:type" content="website">
<meta property="og:url" content="https://taru0208.github.io/toa-research/design-lab/">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Design Lab — Can Math Make Games More Fun?">
<meta name="twitter:description" content="Play two versions of the same combat game and feel the difference. Interactive before/after demo of Anticipation Theory.">
<link rel="canonical" href="https://taru0208.github.io/toa-research/design-lab/">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #080a12;
  color: #c8ccd4;
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  overflow-x: hidden;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
}
h1 { font-size: 22px; font-weight: 700; margin: 14px 0 2px; color: #e0e4ec; letter-spacing: -0.5px; }
.subtitle { font-size: 13px; color: #607090; margin-bottom: 10px; }

/* Phase indicator */
.phase-bar {
  display: flex; gap: 6px; margin-bottom: 8px; align-items: center;
  font-size: 12px; color: #506080;
}
.phase-dot {
  width: 8px; height: 8px; border-radius: 50%; background: #1a2040; border: 1px solid #2a3050;
  transition: all 0.3s;
}
.phase-dot.active { background: #4080c0; border-color: #6090d0; box-shadow: 0 0 6px rgba(64,128,192,0.4); }
.phase-dot.done { background: #40a060; border-color: #50c070; }
.phase-label { margin: 0 4px; }

/* Tab selector */
.tab-bar {
  display: flex; gap: 2px; margin-bottom: 8px; background: #0c0e18; border-radius: 8px; padding: 3px;
  border: 1px solid #1a1e2e;
}
.tab {
  padding: 10px 34px; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600;
  color: #607090; transition: all 0.2s; position: relative;
}
.tab:hover { color: #8090a8; }
.tab.active-a {
  background: linear-gradient(180deg, #1a2040 0%, #121830 100%);
  color: #6090d0; border: 1px solid #304070;
}
.tab.active-b {
  background: linear-gradient(180deg, #1a3020 0%, #122018 100%);
  color: #50c070; border: 1px solid #205030;
}
.tab.locked {
  opacity: 0.35; cursor: default; pointer-events: none;
}
.tab .tab-badge {
  font-size: 9px; position: absolute; top: 3px; right: 6px;
  padding: 1px 5px; border-radius: 3px; font-weight: 600; letter-spacing: 0.3px;
  white-space: nowrap; background: #1a2040; color: #506080;
}
.tab .tab-badge.complete { background: #153020; color: #50c070; }

/* Game area */
#gameContainer { position: relative; width: 800px; max-width: 100vw; }
canvas { display: block; width: 100%; height: auto; border-radius: 8px; }

/* Controls */
#controls {
  display: flex; gap: 8px; padding: 8px 0; justify-content: center; flex-wrap: wrap;
  width: 100%; max-width: 800px;
}
.btn {
  background: linear-gradient(180deg, #1a1e2e 0%, #121520 100%);
  border: 1px solid #2a3050; color: #c8ccd4;
  padding: 10px 16px; border-radius: 8px; font-size: 14px; font-weight: 600;
  cursor: pointer; transition: all 0.15s; min-width: 120px; text-align: center;
}
.btn:hover:not(:disabled) {
  border-color: #4a5580; background: linear-gradient(180deg, #222840 0%, #181c2c 100%);
  transform: translateY(-1px);
}
.btn:active:not(:disabled) { transform: translateY(1px); }
.btn:disabled { opacity: 0.35; cursor: default; }
.btn-strike { border-color: #3060c0; }
.btn-strike:hover:not(:disabled) { border-color: #5080e0; box-shadow: 0 0 12px rgba(48,96,192,0.3); }
.btn-heavy { border-color: #c06030; }
.btn-heavy:hover:not(:disabled) { border-color: #e08050; box-shadow: 0 0 12px rgba(192,96,48,0.3); }
.btn-guard { border-color: #30c060; }
.btn-guard:hover:not(:disabled) { border-color: #50e080; box-shadow: 0 0 12px rgba(48,192,96,0.3); }
.btn-play {
  background: linear-gradient(180deg, #1a3060 0%, #102040 100%);
  border-color: #3070c0; font-size: 16px; padding: 12px 36px; min-width: 140px;
}
.btn-play:hover:not(:disabled) { border-color: #5090e0; box-shadow: 0 0 16px rgba(48,112,192,0.4); }
.btn-next {
  background: linear-gradient(180deg, #1a4030 0%, #102820 100%);
  border-color: #30a060; color: #80e0a0; font-size: 16px; padding: 12px 36px; min-width: 180px;
}
.btn-next:hover:not(:disabled) { border-color: #50c070; box-shadow: 0 0 16px rgba(48,192,96,0.4); }
.btn-sub { font-size: 10px; color: #7080a0; display: block; margin-top: 2px; font-weight: 400; }

/* Log */
#log {
  width: 100%; max-width: 800px; height: 50px; overflow-y: auto;
  padding: 4px 10px; font-size: 12px; line-height: 1.5; color: #8090a8;
  background: #0c0e18; border-radius: 6px; border: 1px solid #1a1e2e;
}
#log::-webkit-scrollbar { width: 4px; }
#log::-webkit-scrollbar-track { background: transparent; }
#log::-webkit-scrollbar-thumb { background: #2a3050; border-radius: 2px; }
.log-player { color: #6090d0; }
.log-enemy { color: #d06060; }
.log-heavy { color: #e09050; font-weight: 600; }
.log-guard { color: #50c070; }
.log-miss { color: #606880; font-style: italic; }
.log-counter { color: #c060c0; }

/* Stats bar */
#stats-bar {
  display: flex; gap: 16px; padding: 4px 0; font-size: 12px; color: #506080;
  max-width: 800px; width: 100%; justify-content: center;
}
.stat-val { color: #8098c0; font-weight: 600; }

/* Comparison panel (bottom) */
#comparison {
  max-width: 800px; width: 100%; margin: 10px 0 20px;
  background: #0c0e18; border: 1px solid #1a2040; border-radius: 8px;
  padding: 14px 18px; font-size: 13px; line-height: 1.6; color: #8090a8;
  display: none;
}
#comparison h3 { font-size: 14px; color: #a0b0d0; margin-bottom: 8px; }
.cmp-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.cmp-col h4 {
  font-size: 11px; color: #607090; margin-bottom: 4px;
  text-transform: uppercase; letter-spacing: 0.5px;
}
.cmp-col.col-a h4 { color: #6090d0; }
.cmp-col.col-b h4 { color: #50c070; }

/* Result reveal */
#result-reveal {
  max-width: 800px; width: 100%; margin: 10px 0 20px;
  background: linear-gradient(180deg, #0e1420 0%, #0c0e18 100%);
  border: 1px solid #1a3050; border-radius: 10px;
  padding: 20px 24px; display: none;
  animation: fadeIn 0.5s ease;
}
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
#result-reveal h3 { font-size: 18px; color: #e0e4ec; margin-bottom: 12px; font-weight: 700; }

.reveal-section { margin: 12px 0; }
.reveal-section h4 { font-size: 13px; color: #8098c0; margin-bottom: 6px; font-weight: 600; }
.reveal-section p { font-size: 13px; color: #8090a8; line-height: 1.7; }
.reveal-highlight { color: #50c070; font-weight: 600; }
.reveal-dim { color: #d06060; font-weight: 600; }

.reveal-data {
  display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 14px 0;
}
.reveal-card {
  background: #101828; border-radius: 8px; padding: 12px 14px;
  border: 1px solid #1a2040;
}
.reveal-card h5 { font-size: 11px; color: #607090; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; }
.reveal-stat {
  display: flex; justify-content: space-between; align-items: center;
  font-size: 13px; color: #8090a8; padding: 3px 0;
}
.reveal-stat .val { font-family: 'Consolas', 'SF Mono', monospace; font-weight: 600; }
.reveal-stat .val.good { color: #50c070; }
.reveal-stat .val.bad { color: #d06060; }
.reveal-stat .val.neutral { color: #8090a8; }

.reveal-insight {
  margin-top: 14px; padding: 12px 16px; border-radius: 8px;
  background: #0e1a14; border: 1px solid #1a3028;
  font-size: 13px; color: #80c090; line-height: 1.7;
}

.reveal-how {
  margin-top: 16px; padding-top: 14px; border-top: 1px solid #1a2040;
}
.reveal-how h4 { font-size: 13px; color: #8098c0; margin-bottom: 8px; }
.reveal-how p { font-size: 12px; color: #607090; line-height: 1.7; }
.reveal-how a { color: #6090c0; text-decoration: none; }
.reveal-how a:hover { text-decoration: underline; }

/* Free play banner */
#free-play-banner {
  max-width: 800px; width: 100%; text-align: center;
  padding: 6px; font-size: 12px; color: #506080;
  display: none;
}

/* Bar charts in reveal */
.bar-container {
  display: flex; align-items: center; gap: 8px; margin: 3px 0;
}
.bar-label { font-size: 11px; color: #607090; width: 80px; text-align: right; }
.bar-track { flex: 1; height: 14px; background: #141828; border-radius: 3px; overflow: hidden; position: relative; }
.bar-fill { height: 100%; border-radius: 3px; transition: width 0.5s ease; }
.bar-value { font-size: 10px; color: #a0b0d0; width: 50px; font-family: 'Consolas', 'SF Mono', monospace; }
</style>
</head>
<body>
<h1>Can Math Make a Game More Fun?</h1>
<p class="subtitle">Play two versions of the same game. See which one feels better.</p>

<div class="phase-bar" id="phaseBar">
  <div class="phase-dot active" id="dot1"></div>
  <span class="phase-label">Version A</span>
  <div class="phase-dot" id="dot2"></div>
  <span class="phase-label">Version B</span>
  <div class="phase-dot" id="dot3"></div>
  <span class="phase-label">Results</span>
</div>

<div class="tab-bar">
  <div class="tab active-a" id="tabA" onclick="trySwitch('before')">
    Version A
    <span class="tab-badge" id="badgeA">0/3</span>
  </div>
  <div class="tab locked" id="tabB" onclick="trySwitch('after')">
    Version B
    <span class="tab-badge" id="badgeB">0/3</span>
  </div>
</div>

<div id="gameContainer">
  <canvas id="canvas" width="800" height="380"></canvas>
  <div id="controls"></div>
  <div id="log"></div>
  <div id="stats-bar">
    <span>Wins: <span class="stat-val" id="sWins">0</span></span>
    <span>Losses: <span class="stat-val" id="sLosses">0</span></span>
    <span>Win rate: <span class="stat-val" id="sWinRate">-</span></span>
  </div>
</div>

<div id="free-play-banner">
  Switch freely between Version A and B. Press [1] or [2], or click the tabs above.
</div>

<div id="result-reveal">
  <!-- Filled dynamically after both versions played -->
</div>

<div id="comparison">
  <!-- Used for free-play stats after reveal -->
</div>

<script>
// ============================================================
//  DESIGN LAB — Guided Before/After Experience
// ============================================================

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 800, H = 380;
const controlsEl = document.getElementById('controls');
const logEl = document.getElementById('log');

// === FLOW STATE ===
// phase: 'a' (playing version A) → 'b' (playing version B) → 'reveal' (showing results) → 'free' (free play)
let flowPhase = 'a';
const GAMES_REQUIRED = 3;

// === TWO CONFIGURATIONS ===
const CONFIGS = {
  before: {
    label: 'Version A',
    MAX_HP: 5,
    STRIKE_DMG: 1,
    HEAVY_DMG: 2,
    HEAVY_HIT: 0.50,
    GUARD_COUNTER: 1,
    GUARD_BLOCK: 0.50,
    accentColor: '#6090d0',
    bgTint: [14, 16, 24],
  },
  after: {
    label: 'Version B',
    MAX_HP: 5,
    STRIKE_DMG: 1,
    HEAVY_DMG: 3,
    HEAVY_HIT: 0.70,
    GUARD_COUNTER: 2,
    GUARD_BLOCK: 0.70,
    accentColor: '#50c070',
    bgTint: [12, 24, 16],
  }
};

let currentMode = 'before';
let cfg = CONFIGS.before;

// Per-mode stats (fresh each session for the guided flow)
const modeStats = {
  before: { wins: 0, losses: 0, heavyCount: 0, totalActions: 0, gamesPlayed: 0 },
  after: { wins: 0, losses: 0, heavyCount: 0, totalActions: 0, gamesPlayed: 0 },
};

function trySwitch(mode) {
  if (flowPhase === 'a' && mode === 'after') return; // locked
  if (flowPhase === 'b' && mode === 'before') return; // locked during B phase
  if (mode === currentMode) return;
  switchMode(mode);
}

function switchMode(mode) {
  currentMode = mode;
  cfg = CONFIGS[mode];
  document.getElementById('tabA').className = mode === 'before' ? 'tab active-a' : 'tab';
  document.getElementById('tabB').className = mode === 'after' ? 'tab active-b' : 'tab';
  winProbCache = {};
  precomputeWinProb();
  gameState = 'title';
  updateButtons();
  updateBadges();
}

function updateBadges() {
  const ba = document.getElementById('badgeA');
  const bb = document.getElementById('badgeB');
  const ga = modeStats.before.gamesPlayed;
  const gb = modeStats.after.gamesPlayed;
  ba.textContent = ga >= GAMES_REQUIRED ? '✓' : `${ga}/${GAMES_REQUIRED}`;
  bb.textContent = gb >= GAMES_REQUIRED ? '✓' : `${gb}/${GAMES_REQUIRED}`;
  ba.className = ga >= GAMES_REQUIRED ? 'tab-badge complete' : 'tab-badge';
  bb.className = gb >= GAMES_REQUIRED ? 'tab-badge complete' : 'tab-badge';
}

function updatePhaseUI() {
  const d1 = document.getElementById('dot1');
  const d2 = document.getElementById('dot2');
  const d3 = document.getElementById('dot3');
  d1.className = 'phase-dot' + (flowPhase === 'a' ? ' active' : ' done');
  d2.className = 'phase-dot' + (flowPhase === 'b' ? ' active' : (flowPhase === 'reveal' || flowPhase === 'free' ? ' done' : ''));
  d3.className = 'phase-dot' + (flowPhase === 'reveal' || flowPhase === 'free' ? ' active' : '');

  // Tab locking
  const tabA = document.getElementById('tabA');
  const tabB = document.getElementById('tabB');
  if (flowPhase === 'a') {
    tabB.classList.add('locked');
    tabA.classList.remove('locked');
  } else if (flowPhase === 'b') {
    tabA.classList.add('locked');
    tabB.classList.remove('locked');
  } else {
    tabA.classList.remove('locked');
    tabB.classList.remove('locked');
  }

  // Phase bar visibility
  document.getElementById('phaseBar').style.display = flowPhase === 'free' ? 'none' : 'flex';
  document.getElementById('free-play-banner').style.display = flowPhase === 'free' ? 'block' : 'none';
}

function checkPhaseTransition() {
  if (flowPhase === 'a' && modeStats.before.gamesPlayed >= GAMES_REQUIRED) {
    // Don't auto-transition — show a "Next" button
    return;
  }
  if (flowPhase === 'b' && modeStats.after.gamesPlayed >= GAMES_REQUIRED) {
    // Show reveal
    return;
  }
}

function advanceToB() {
  flowPhase = 'b';
  switchMode('after');
  updatePhaseUI();
  gameState = 'title';
  updateButtons();
}

function showReveal() {
  flowPhase = 'reveal';
  updatePhaseUI();
  document.getElementById('result-reveal').style.display = 'block';
  buildRevealContent();

  // Scroll to reveal
  setTimeout(() => {
    document.getElementById('result-reveal').scrollIntoView({ behavior: 'smooth', block: 'start' });
  }, 100);
}

function enterFreePlay() {
  flowPhase = 'free';
  updatePhaseUI();
  document.getElementById('result-reveal').style.display = 'block';
  // Show comparison panel for ongoing stats
  document.getElementById('comparison').style.display = 'block';
  buildComparisonPanel();
  gameState = 'title';
  updateButtons();
}

function buildRevealContent() {
  const r = document.getElementById('result-reveal');
  const bSt = modeStats.before;
  const aSt = modeStats.after;
  const bTotal = bSt.wins + bSt.losses;
  const aTotal = aSt.wins + aSt.losses;
  const bWR = bTotal > 0 ? (bSt.wins / bTotal * 100) : 0;
  const aWR = aTotal > 0 ? (aSt.wins / aTotal * 100) : 0;
  const bHR = bSt.totalActions > 0 ? (bSt.heavyCount / bSt.totalActions * 100) : 0;
  const aHR = aSt.totalActions > 0 ? (aSt.heavyCount / aSt.totalActions * 100) : 0;

  // Determine insight
  let insightHTML = '';
  const moreAggressiveInB = aHR > bHR + 3;
  const wonMoreInB = aWR > bWR + 5;

  if (moreAggressiveInB && wonMoreInB) {
    insightHTML = `You attacked more aggressively in Version B — and <strong>won more because of it</strong>. That's the whole point: Version B rewards exciting play instead of punishing it.`;
  } else if (moreAggressiveInB && !wonMoreInB) {
    insightHTML = `You went more aggressive in Version B. The win rates are close — with more games, you'd likely see that aggressive play pays off in B. Version A punishes that same instinct.`;
  } else if (!moreAggressiveInB && wonMoreInB) {
    insightHTML = `Interesting — you played similarly in both versions but won more in B. That's because even cautious play benefits from Version B's higher damage values. Try going all-out aggressive in B next time!`;
  } else {
    insightHTML = `You played both versions similarly. Try an experiment: play super aggressively in Version B (Heavy attack every turn) and see what happens to your win rate. Then try the same in Version A.`;
  }

  r.innerHTML = `
    <h3>Here's What Happened</h3>

    <div class="reveal-data">
      <div class="reveal-card">
        <h5>Version A</h5>
        <div class="reveal-stat"><span>Win rate</span><span class="val ${bWR >= 50 ? 'neutral' : 'bad'}">${bWR.toFixed(0)}%</span></div>
        <div class="reveal-stat"><span>Heavy attack usage</span><span class="val neutral">${bHR.toFixed(0)}%</span></div>
        <div class="reveal-stat"><span>Games played</span><span class="val neutral">${bTotal}</span></div>
      </div>
      <div class="reveal-card">
        <h5>Version B</h5>
        <div class="reveal-stat"><span>Win rate</span><span class="val ${aWR >= 50 ? 'good' : 'neutral'}">${aWR.toFixed(0)}%</span></div>
        <div class="reveal-stat"><span>Heavy attack usage</span><span class="val neutral">${aHR.toFixed(0)}%</span></div>
        <div class="reveal-stat"><span>Games played</span><span class="val neutral">${aTotal}</span></div>
      </div>
    </div>

    <div class="reveal-insight">${insightHTML}</div>

    <div class="reveal-section">
      <h4>So what's different?</h4>
      <p>Both versions have the <strong style="color:#c0d0e8">exact same rules</strong> — Strike, Heavy, Guard. Same structure, same choices.<br>
      The only difference is the <strong style="color:#c0d0e8">numbers</strong>:</p>
      <div class="reveal-data" style="margin-top:8px;">
        <div class="reveal-card">
          <h5>Version A numbers</h5>
          <div class="reveal-stat"><span>Heavy attack</span><span class="val bad">2 damage, 50% hit</span></div>
          <div class="reveal-stat"><span>Guard counter</span><span class="val neutral">1 damage</span></div>
          <div style="margin-top:6px; font-size:12px; color:#c08090;">→ Playing safe wins. Attacking is punished.</div>
        </div>
        <div class="reveal-card">
          <h5>Version B numbers</h5>
          <div class="reveal-stat"><span>Heavy attack</span><span class="val good">3 damage, 70% hit</span></div>
          <div class="reveal-stat"><span>Guard counter</span><span class="val neutral">2 damage</span></div>
          <div style="margin-top:6px; font-size:12px; color:#80c090;">→ Attacking pays off. The exciting move IS the smart move.</div>
        </div>
      </div>
    </div>

    <div class="reveal-how">
      <h4>Why does this matter?</h4>
      <p>Many games have a hidden problem: the <strong style="color:#c08090;">boring, safe strategy is the best strategy</strong>.
      Players have to choose between having fun and winning — a bad trade-off.</p>
      <p style="margin-top:6px;">By adjusting the numbers, we can make the exciting play <em>also</em> the winning play.
      Same game, same rules — just better balanced.</p>
      <p style="margin-top:6px;">This is based on research into <a href="https://github.com/akalouis/anticipation-theory" target="_blank">Anticipation Theory</a>
      — a mathematical framework for measuring and improving the "fun" structure of games.
      <a href="../about">Learn more about the math →</a></p>
    </div>

    <div style="text-align:center; margin-top:18px;">
      <button class="btn btn-next" onclick="enterFreePlay()">Keep Playing — Free Mode</button>
    </div>
  `;
}

function buildComparisonPanel() {
  const cp = document.getElementById('comparison');
  cp.innerHTML = `
    <h3>Your Stats (all games)</h3>
    <div class="cmp-grid">
      <div class="cmp-col col-a">
        <h4>Version A</h4>
        <div class="bar-container">
          <span class="bar-label">Win rate</span>
          <div class="bar-track"><div class="bar-fill" id="bar-a-wr" style="width:0;background:#6090d0"></div></div>
          <span class="bar-value" id="val-a-wr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Heavy%</span>
          <div class="bar-track"><div class="bar-fill" id="bar-a-hr" style="width:0;background:#e09050"></div></div>
          <span class="bar-value" id="val-a-hr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Games</span>
          <div class="bar-track"><div class="bar-fill" id="bar-a-gm" style="width:0;background:#5070a0"></div></div>
          <span class="bar-value" id="val-a-gm">0</span>
        </div>
      </div>
      <div class="cmp-col col-b">
        <h4>Version B</h4>
        <div class="bar-container">
          <span class="bar-label">Win rate</span>
          <div class="bar-track"><div class="bar-fill" id="bar-b-wr" style="width:0;background:#50c070"></div></div>
          <span class="bar-value" id="val-b-wr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Heavy%</span>
          <div class="bar-track"><div class="bar-fill" id="bar-b-hr" style="width:0;background:#e09050"></div></div>
          <span class="bar-value" id="val-b-hr">-</span>
        </div>
        <div class="bar-container">
          <span class="bar-label">Games</span>
          <div class="bar-track"><div class="bar-fill" id="bar-b-gm" style="width:0;background:#5070a0"></div></div>
          <span class="bar-value" id="val-b-gm">0</span>
        </div>
      </div>
    </div>
  `;
  updateComparisonBars();
}

// === AUDIO ===
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playSound(type) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const g = audioCtx.createGain();
  g.connect(audioCtx.destination);
  const o = audioCtx.createOscillator();
  o.connect(g);
  switch(type) {
    case 'hit':
      o.type = 'sawtooth'; o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.15);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      o.start(now); o.stop(now + 0.2); break;
    case 'heavy':
      o.type = 'sawtooth'; o.frequency.setValueAtTime(150, now);
      o.frequency.exponentialRampToValueAtTime(40, now + 0.3);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      o.start(now); o.stop(now + 0.35);
      const o2 = audioCtx.createOscillator(), g2 = audioCtx.createGain();
      o2.connect(g2); g2.connect(audioCtx.destination);
      o2.type = 'sine'; o2.frequency.setValueAtTime(60, now);
      g2.gain.setValueAtTime(0.15, now);
      g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      o2.start(now); o2.stop(now + 0.4); break;
    case 'miss':
      o.type = 'sine'; o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(150, now + 0.2);
      g.gain.setValueAtTime(0.06, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
      o.start(now); o.stop(now + 0.25); break;
    case 'guard':
      o.type = 'triangle'; o.frequency.setValueAtTime(500, now);
      o.frequency.exponentialRampToValueAtTime(700, now + 0.1);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      o.start(now); o.stop(now + 0.15); break;
    case 'counter':
      o.type = 'square'; o.frequency.setValueAtTime(150, now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.25);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
      o.start(now); o.stop(now + 0.3); break;
    case 'block':
      o.type = 'triangle'; o.frequency.setValueAtTime(600, now);
      o.frequency.exponentialRampToValueAtTime(300, now + 0.15);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      o.start(now); o.stop(now + 0.2); break;
    case 'win':
      o.type = 'triangle';
      [400,500,600,800].forEach((f,i) => o.frequency.setValueAtTime(f, now + i * 0.12));
      g.gain.setValueAtTime(0.1, now);
      g.gain.setValueAtTime(0.1, now + 0.45);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
      o.start(now); o.stop(now + 0.7); break;
    case 'lose':
      o.type = 'sawtooth'; o.frequency.setValueAtTime(250, now);
      o.frequency.exponentialRampToValueAtTime(60, now + 0.6);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
      o.start(now); o.stop(now + 0.7); break;
    case 'select':
      o.type = 'sine'; o.frequency.setValueAtTime(600, now);
      o.frequency.exponentialRampToValueAtTime(800, now + 0.06);
      g.gain.setValueAtTime(0.05, now);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      o.start(now); o.stop(now + 0.08); break;
  }
}

// === PARTICLES ===
const particles = [];
function spawnParticles(x, y, color, count, speed, life, size) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const spd = (Math.random() * 0.6 + 0.4) * speed;
    particles.push({
      x, y, vx: Math.cos(angle) * spd, vy: Math.sin(angle) * spd - Math.random() * 1.5,
      life: life * (0.7 + Math.random() * 0.6), maxLife: life * (0.7 + Math.random() * 0.6),
      color, size: size * (0.5 + Math.random() * 0.5), gravity: 0.08
    });
  }
}
function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt; p.y += p.vy * dt; p.vy += p.gravity * dt; p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}
function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life / p.maxLife) * 0.9;
    ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (p.life / p.maxLife), 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// === FLOATING TEXT ===
const floatingTexts = [];
function spawnFloat(x, y, text, color, size) {
  floatingTexts.push({ x, y, text, color, size: size || 20, life: 50, maxLife: 50, vy: -1.5 });
}
function updateFloats(dt) {
  for (let i = floatingTexts.length - 1; i >= 0; i--) {
    const t = floatingTexts[i];
    t.y += t.vy * dt; t.vy *= 0.98; t.life -= dt;
    if (t.life <= 0) floatingTexts.splice(i, 1);
  }
}
function drawFloats() {
  for (const t of floatingTexts) {
    const a = Math.max(0, t.life / t.maxLife);
    const s = 1 + (1 - a) * 0.3;
    ctx.save(); ctx.globalAlpha = a;
    ctx.font = `bold ${Math.round(t.size * s)}px 'Segoe UI', system-ui, sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#000'; ctx.fillText(t.text, t.x + 2, t.y + 2);
    ctx.fillStyle = t.color; ctx.fillText(t.text, t.x, t.y);
    ctx.restore();
  }
}

// === SCREEN SHAKE ===
let shakeAmt = 0, shakeDur = 0;
function shake(a, d) { shakeAmt = a; shakeDur = d; }
function shakeOff() {
  if (shakeDur <= 0) return { x: 0, y: 0 };
  const i = shakeDur / 20 * shakeAmt;
  return { x: (Math.random() - 0.5) * i * 2, y: (Math.random() - 0.5) * i * 2 };
}

// === FIGHTER ===
class FighterAnim {
  constructor(bx, by) {
    this.bx = bx; this.by = by; this.x = bx; this.y = by;
    this.hf = 0; this.bp = Math.random() * Math.PI * 2;
    this.atk = false; this.ax = 0; this.ap = 0;
  }
  update(dt) {
    this.bp += 0.03 * dt; this.y = this.by + Math.sin(this.bp) * 2;
    if (this.hf > 0) this.hf -= 0.03 * dt;
    if (this.atk) {
      this.ap += 0.06 * dt;
      if (this.ap < 1) this.x = this.bx + this.ax * Math.sin(this.ap * Math.PI);
      else { this.atk = false; this.ap = 0; this.x = this.bx; }
    }
  }
  attack(tx) { this.atk = true; this.ap = 0; this.ax = (tx - this.bx) * 0.4; }
  flash() { this.hf = 1; }
}

function drawFighter(x, y, color, hp, maxHp, guarding, faceLeft, hitFlash, name) {
  ctx.save();
  const fl = hitFlash > 0 ? `rgba(255,255,255,${hitFlash * 0.6})` : null;

  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath(); ctx.ellipse(x, y + 48, 22, 6, 0, 0, Math.PI * 2); ctx.fill();

  if (guarding) {
    ctx.strokeStyle = '#50e080'; ctx.lineWidth = 2.5;
    ctx.globalAlpha = 0.4 + Math.sin(Date.now() * 0.006) * 0.15;
    ctx.beginPath(); ctx.ellipse(x, y - 10, 35, 50, 0, 0, Math.PI * 2); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  const d = faceLeft ? -1 : 1;

  ctx.strokeStyle = fl || color; ctx.lineWidth = 4; ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x - 6, y + 20); ctx.lineTo(x - 10, y + 45);
  ctx.moveTo(x + 6, y + 20); ctx.lineTo(x + 10, y + 45);
  ctx.stroke();

  ctx.fillStyle = fl || color;
  ctx.beginPath(); ctx.roundRect(x - 12, y - 15, 24, 38, 4); ctx.fill();

  ctx.strokeStyle = fl || color; ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.moveTo(x - 12 * d, y - 5); ctx.lineTo(x - 22 * d, y + 10);
  ctx.moveTo(x + 12 * d, y - 5); ctx.lineTo(x + 22 * d, y + 5);
  ctx.stroke();

  ctx.fillStyle = fl || color;
  ctx.beginPath(); ctx.arc(x, y - 28, 14, 0, Math.PI * 2); ctx.fill();

  const ex = faceLeft ? -4 : 4;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(x + ex - 3, y - 30, 3, 0, Math.PI * 2);
  ctx.arc(x + ex + 5, y - 30, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(x + ex - 3 + (faceLeft ? -0.5 : 0.5), y - 30, 1.5, 0, Math.PI * 2);
  ctx.arc(x + ex + 5 + (faceLeft ? -0.5 : 0.5), y - 30, 1.5, 0, Math.PI * 2);
  ctx.fill();

  const bw = 60, bh = 7, bx = x - bw/2, by = y - 55;
  ctx.fillStyle = '#1a1020'; ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
  const r = Math.max(0, hp / maxHp);
  ctx.fillStyle = r > 0.5 ? '#40c070' : r > 0.25 ? '#d0a030' : '#d04040';
  ctx.fillRect(bx, by, bw * r, bh);

  ctx.font = 'bold 12px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center'; ctx.fillStyle = '#506080';
  ctx.fillText(name, x, by - 6);

  ctx.font = '11px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#8090a8';
  ctx.fillText(`${hp}/${maxHp}`, x, by + bh + 14);

  ctx.restore();
}

// === WIN PROBABILITY (DP) ===
let winProbCache = {};
function computeWinProb(ph, eh) {
  const key = `${ph},${eh}`;
  if (winProbCache[key] !== undefined) return winProbCache[key];
  if (ph <= 0 && eh <= 0) { winProbCache[key] = 0.5; return 0.5; }
  if (ph <= 0) { winProbCache[key] = 0; return 0; }
  if (eh <= 0) { winProbCache[key] = 1; return 1; }
  winProbCache[key] = 0.5;

  const hh = cfg.HEAVY_HIT, gb = cfg.GUARD_BLOCK;
  const hd = cfg.HEAVY_DMG, sd = cfg.STRIKE_DMG, gc = cfg.GUARD_COUNTER;
  let nls = 0, slw = 0;

  nls += computeWinProb(ph - sd, eh - sd);
  nls += hh * computeWinProb(ph - hd, eh) + (1-hh) * computeWinProb(ph, eh - gc);
  slw += 1;
  nls += hh * computeWinProb(ph, eh - hd) + (1-hh) * computeWinProb(ph - gc, eh);
  nls += hh*hh * computeWinProb(ph - hd, eh - hd) +
         hh*(1-hh) * computeWinProb(ph, eh - hd) +
         (1-hh)*hh * computeWinProb(ph - hd, eh);
  slw += (1-hh)*(1-hh);
  slw += gb;
  nls += (1-gb) * hh * computeWinProb(ph, eh - hd);
  slw += (1-gb) * (1-hh);
  slw += 1;
  slw += gb;
  nls += (1-gb) * hh * computeWinProb(ph - hd, eh);
  slw += (1-gb) * (1-hh);
  slw += 1;

  const result = nls / (9 - slw);
  winProbCache[key] = result;
  return result;
}

function precomputeWinProb() {
  winProbCache = {};
  for (let t = 0; t <= cfg.MAX_HP * 2; t++) {
    for (let p = 0; p <= Math.min(t, cfg.MAX_HP); p++) {
      const e = t - p;
      if (e >= 0 && e <= cfg.MAX_HP) {
        delete winProbCache[`${p},${e}`];
        computeWinProb(p, e);
      }
    }
  }
}
precomputeWinProb();

// === GAME STATE ===
let gameState = 'title';
let player = { hp: cfg.MAX_HP, guarding: false };
let enemy = { hp: cfg.MAX_HP, guarding: false };
let pAnim, eAnim;
let turnQueue = [], animTimer = 0, canAct = false, turnCount = 0, titlePulse = 0;
let wpHistory = [];

function resetBattle() {
  player = { hp: cfg.MAX_HP, guarding: false };
  enemy = { hp: cfg.MAX_HP, guarding: false };
  pAnim = new FighterAnim(230, 220);
  eAnim = new FighterAnim(570, 220);
  turnQueue = []; animTimer = 0; canAct = true; turnCount = 0;
  logEl.innerHTML = '';
  gameState = 'battle';
  wpHistory = [0.5];
  updateButtons();
}

function addLog(html) {
  const d = document.createElement('div'); d.innerHTML = html;
  logEl.appendChild(d); logEl.scrollTop = logEl.scrollHeight;
}

// === AI ===
function aiDecide() {
  const w = { strike: 30, heavy: 35, guard: 35 };
  if (enemy.hp <= 2) { w.heavy = 50; w.guard = 15; }
  if (player.hp <= 2) { w.heavy = 45; w.strike = 35; }
  const total = w.strike + w.heavy + w.guard;
  let r = Math.random() * total;
  if (r < w.strike) return 'strike';
  r -= w.strike;
  if (r < w.heavy) return 'heavy';
  return 'guard';
}

// === COMBAT ===
function resolveAction(action, oppAction, isPlayer) {
  const name = isPlayer ? 'You' : 'CPU';
  const def = isPlayer ? 'CPU' : 'You';
  const events = [];
  let dmgOpp = 0, dmgSelf = 0;

  if (action === 'guard') {
    events.push({ type: 'guard', isPlayer, log: `<span class="log-guard">${name} raised guard.</span>` });
    return { dmgOpp, dmgSelf, events };
  }

  if (action === 'strike') {
    if (oppAction === 'guard') {
      events.push({ type: 'blocked', isPlayer, log: `<span class="log-miss">${name}'s strike was blocked.</span>` });
    } else {
      dmgOpp = cfg.STRIKE_DMG;
      events.push({ type: 'hit', isPlayer, dmg: cfg.STRIKE_DMG, log: `<span class="log-player">${name} struck for ${cfg.STRIKE_DMG}.</span>` });
    }
    return { dmgOpp, dmgSelf, events };
  }

  if (action === 'heavy') {
    if (oppAction === 'guard' && Math.random() < cfg.GUARD_BLOCK) {
      events.push({ type: 'blocked', isPlayer, log: `<span class="log-guard">${def} blocked the heavy!</span>` });
      return { dmgOpp, dmgSelf, events };
    }
    if (Math.random() < cfg.HEAVY_HIT) {
      dmgOpp = cfg.HEAVY_DMG;
      events.push({ type: 'heavy_hit', isPlayer, dmg: cfg.HEAVY_DMG, log: `<span class="log-heavy">${name} lands heavy — ${cfg.HEAVY_DMG} damage!</span>` });
    } else {
      dmgSelf = cfg.GUARD_COUNTER;
      events.push({ type: 'miss', isPlayer, log: `<span class="log-miss">${name}'s heavy missed!</span>` });
      events.push({ type: 'counter', isPlayer: !isPlayer, dmg: cfg.GUARD_COUNTER, log: `<span class="log-counter">${def} countered for ${cfg.GUARD_COUNTER}!</span>` });
    }
    return { dmgOpp, dmgSelf, events };
  }
  return { dmgOpp, dmgSelf, events };
}

function resolveTurn(pAction, eAction) {
  turnCount++;
  player.guarding = false; enemy.guarding = false;
  const pR = resolveAction(pAction, eAction, true);
  const eR = resolveAction(eAction, pAction, false);
  enemy.hp = Math.max(0, enemy.hp - pR.dmgOpp);
  player.hp = Math.max(0, player.hp - pR.dmgSelf);
  player.hp = Math.max(0, player.hp - eR.dmgOpp);
  enemy.hp = Math.max(0, enemy.hp - eR.dmgSelf);
  if (pAction === 'guard') player.guarding = true;
  if (eAction === 'guard') enemy.guarding = true;
  const events = [...pR.events, ...eR.events];
  wpHistory.push(computeWinProb(player.hp, enemy.hp));
  if (player.hp <= 0 || enemy.hp <= 0) {
    if (player.hp <= 0 && enemy.hp <= 0) events.push({ type: 'draw', log: 'Draw!' });
    else if (enemy.hp <= 0) events.push({ type: 'win', log: '<span class="log-player">Victory!</span>' });
    else events.push({ type: 'lose', log: '<span class="log-enemy">Defeat!</span>' });
  }
  return events;
}

function executeTurn(pAction) {
  if (!canAct || gameState !== 'battle') return;
  ensureAudio(); playSound('select'); canAct = false;
  const st = modeStats[currentMode];
  st.totalActions++;
  if (pAction === 'heavy') st.heavyCount++;
  const eAction = aiDecide();
  turnQueue = resolveTurn(pAction, eAction);
  gameState = 'animating'; animTimer = 0;
  processEvent();
}

function onGameEnd() {
  const st = modeStats[currentMode];
  st.gamesPlayed++;
  updateBadges();

  // Check phase transitions
  if (flowPhase === 'a' && st.gamesPlayed >= GAMES_REQUIRED) {
    // Will show "Try Version B" button
  } else if (flowPhase === 'b' && st.gamesPlayed >= GAMES_REQUIRED) {
    // Will show "See Results" button
  }

  if (flowPhase === 'free') {
    updateComparisonBars();
  }
}

function processEvent() {
  if (turnQueue.length === 0) {
    if (player.hp <= 0 || enemy.hp <= 0) {
      gameState = 'gameover';
      const st = modeStats[currentMode];
      if (enemy.hp <= 0 && player.hp > 0) { st.wins++; playSound('win'); }
      else if (player.hp <= 0 && enemy.hp > 0) { st.losses++; playSound('lose'); }
      onGameEnd();
    } else { gameState = 'battle'; canAct = true; }
    updateButtons(); return;
  }
  const ev = turnQueue.shift(); animTimer = 0;
  addLog(ev.log);
  const px = pAnim.x, py = pAnim.y, ex = eAnim.x, ey = eAnim.y;
  switch(ev.type) {
    case 'hit':
      if (ev.isPlayer) {
        pAnim.attack(ex);
        setTimeout(() => { eAnim.flash(); spawnParticles(ex, ey-10, '#6090d0', 8, 3, 25, 3); spawnFloat(ex, ey-60, `-${cfg.STRIKE_DMG}`, '#6090d0'); playSound('hit'); shake(3,8); }, 200);
      } else {
        eAnim.attack(px);
        setTimeout(() => { pAnim.flash(); spawnParticles(px, py-10, '#d06060', 8, 3, 25, 3); spawnFloat(px, py-60, `-${cfg.STRIKE_DMG}`, '#d06060'); playSound('hit'); shake(3,8); }, 200);
      }
      setTimeout(processEvent, 500); break;
    case 'heavy_hit':
      if (ev.isPlayer) {
        pAnim.attack(ex);
        setTimeout(() => { eAnim.flash(); spawnParticles(ex, ey-10, '#e09050', 18, 5, 35, 4); spawnFloat(ex, ey-60, `-${cfg.HEAVY_DMG}`, '#e09050', 26); playSound('heavy'); shake(6,15); }, 200);
      } else {
        eAnim.attack(px);
        setTimeout(() => { pAnim.flash(); spawnParticles(px, py-10, '#e09050', 18, 5, 35, 4); spawnFloat(px, py-60, `-${cfg.HEAVY_DMG}`, '#e09050', 26); playSound('heavy'); shake(6,15); }, 200);
      }
      setTimeout(processEvent, 600); break;
    case 'miss': playSound('miss'); setTimeout(processEvent, 300); break;
    case 'counter':
      if (ev.isPlayer) {
        spawnParticles(ex, ey-10, '#c060c0', 12, 4, 30, 3);
        spawnFloat(ex, ey-60, `-${cfg.GUARD_COUNTER}`, '#c060c0'); eAnim.flash(); playSound('counter'); shake(4,10);
      } else {
        spawnParticles(px, py-10, '#c060c0', 12, 4, 30, 3);
        spawnFloat(px, py-60, `-${cfg.GUARD_COUNTER}`, '#c060c0'); pAnim.flash(); playSound('counter'); shake(4,10);
      }
      setTimeout(processEvent, 500); break;
    case 'blocked':
      playSound('block');
      const bx = ev.isPlayer ? ex : px, by = ev.isPlayer ? ey : py;
      spawnParticles(bx, by-10, '#50e080', 6, 2, 20, 2);
      spawnFloat(bx, by-60, 'BLOCKED', '#50e080', 16);
      setTimeout(processEvent, 400); break;
    case 'guard': playSound('guard'); setTimeout(processEvent, 250); break;
    default: setTimeout(processEvent, 100); break;
  }
}

// === BUTTONS ===
function updateButtons() {
  controlsEl.innerHTML = '';
  if (gameState === 'title') {
    // Check if we need transition buttons
    if (flowPhase === 'a' && modeStats.before.gamesPlayed >= GAMES_REQUIRED) {
      const btn = document.createElement('button');
      btn.className = 'btn btn-next';
      btn.textContent = 'Now Try Version B →';
      btn.onclick = () => { ensureAudio(); advanceToB(); };
      controlsEl.appendChild(btn);
      return;
    }
    if (flowPhase === 'b' && modeStats.after.gamesPlayed >= GAMES_REQUIRED) {
      const btn = document.createElement('button');
      btn.className = 'btn btn-next';
      btn.textContent = 'See the Results →';
      btn.onclick = () => { showReveal(); };
      controlsEl.appendChild(btn);
      return;
    }

    const btn = document.createElement('button');
    btn.className = 'btn btn-play';
    btn.textContent = 'FIGHT';
    btn.onclick = () => { ensureAudio(); resetBattle(); };
    controlsEl.appendChild(btn);
  } else if (gameState === 'battle' && canAct) {
    const actions = [
      { id: 'strike', label: 'Strike', sub: `${cfg.STRIKE_DMG} dmg (reliable) [Q]`, cls: 'btn-strike' },
      { id: 'heavy', label: 'Heavy', sub: `${cfg.HEAVY_DMG} dmg @ ${Math.round(cfg.HEAVY_HIT*100)}% [W]`, cls: 'btn-heavy' },
      { id: 'guard', label: 'Guard', sub: `block + counter ${cfg.GUARD_COUNTER} [E]`, cls: 'btn-guard' },
    ];
    actions.forEach(a => {
      const btn = document.createElement('button');
      btn.className = `btn ${a.cls}`;
      btn.innerHTML = `${a.label} <span class="btn-sub">${a.sub}</span>`;
      btn.onclick = () => executeTurn(a.id);
      controlsEl.appendChild(btn);
    });
  } else if (gameState === 'gameover') {
    // Check if current phase needs transition
    const st = modeStats[currentMode];
    if (flowPhase === 'a' && st.gamesPlayed >= GAMES_REQUIRED) {
      const btn = document.createElement('button');
      btn.className = 'btn btn-next';
      btn.textContent = 'Now Try Version B →';
      btn.onclick = () => { ensureAudio(); advanceToB(); };
      controlsEl.appendChild(btn);
    } else if (flowPhase === 'b' && st.gamesPlayed >= GAMES_REQUIRED) {
      const btn = document.createElement('button');
      btn.className = 'btn btn-next';
      btn.textContent = 'See the Results →';
      btn.onclick = () => { showReveal(); };
      controlsEl.appendChild(btn);
    } else {
      const btn = document.createElement('button');
      btn.className = 'btn btn-play';
      btn.textContent = 'FIGHT AGAIN';
      btn.onclick = () => { ensureAudio(); resetBattle(); };
      controlsEl.appendChild(btn);
    }
  }
}

// === KEYBOARD ===
document.addEventListener('keydown', e => {
  if (gameState === 'battle' && canAct) {
    if (e.key === 'q' || e.key === 'Q') executeTurn('strike');
    else if (e.key === 'w' || e.key === 'W') executeTurn('heavy');
    else if (e.key === 'e' || e.key === 'E') executeTurn('guard');
  } else if (gameState === 'title' || gameState === 'gameover') {
    if (e.key === ' ' || e.key === 'Enter') {
      // Handle transitions
      const st = modeStats[currentMode];
      if (flowPhase === 'a' && st.gamesPlayed >= GAMES_REQUIRED) { ensureAudio(); advanceToB(); return; }
      if (flowPhase === 'b' && st.gamesPlayed >= GAMES_REQUIRED) { showReveal(); return; }
      ensureAudio(); resetBattle();
    }
  }
  // Tab switching only in free play
  if (flowPhase === 'free') {
    if (e.key === '1') trySwitch('before');
    if (e.key === '2') trySwitch('after');
  }
});

// === WIN PROB CHART ===
function drawWPChart(x, y, w, h) {
  if (wpHistory.length < 1) return;
  ctx.save();
  ctx.fillStyle = 'rgba(10, 12, 24, 0.85)';
  ctx.beginPath(); ctx.roundRect(x-4, y-18, w+8, h+28, 6); ctx.fill();
  ctx.strokeStyle = '#1a2040'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(x-4, y-18, w+8, h+28, 6); ctx.stroke();
  ctx.font = '10px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#506080'; ctx.textAlign = 'left';
  ctx.fillText('Win Chance', x, y - 6);
  const cp = wpHistory[wpHistory.length - 1];
  ctx.textAlign = 'right';
  ctx.fillStyle = cp > 0.5 ? '#50c070' : cp < 0.5 ? '#d06060' : '#8090a8';
  ctx.font = 'bold 10px "Segoe UI", system-ui, sans-serif';
  ctx.fillText(`${(cp * 100).toFixed(0)}%`, x + w, y - 6);
  ctx.strokeStyle = '#2a3050'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
  ctx.beginPath(); ctx.moveTo(x, y + h/2); ctx.lineTo(x + w, y + h/2); ctx.stroke();
  ctx.setLineDash([]);
  if (wpHistory.length >= 2) {
    const step = w / Math.max(1, wpHistory.length - 1);
    ctx.beginPath();
    for (let i = 0; i < wpHistory.length; i++) {
      const px2 = x + i * step, py2 = y + h - wpHistory[i] * h;
      if (i === 0) ctx.moveTo(px2, py2); else ctx.lineTo(px2, py2);
    }
    ctx.strokeStyle = cfg.accentColor; ctx.lineWidth = 2; ctx.stroke();
    ctx.lineTo(x + (wpHistory.length - 1) * step, y + h);
    ctx.lineTo(x, y + h); ctx.closePath();
    const grad = ctx.createLinearGradient(0, y, 0, y + h);
    grad.addColorStop(0, cfg.accentColor.replace(')', ',0.15)').replace('rgb', 'rgba'));
    grad.addColorStop(1, 'rgba(80,128,192,0.02)');
    ctx.fillStyle = grad; ctx.fill();
  }
  if (wpHistory.length > 0) {
    const lx = x + (wpHistory.length - 1) * (w / Math.max(1, wpHistory.length - 1));
    const ly = y + h - cp * h;
    ctx.fillStyle = cfg.accentColor;
    ctx.beginPath(); ctx.arc(lx, ly, 4, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#c0d0e0';
    ctx.beginPath(); ctx.arc(lx, ly, 2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

// === MODE INDICATOR (on canvas) ===
function drawModeIndicator() {
  const label = cfg.label;
  ctx.save();
  ctx.font = 'bold 13px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = cfg.accentColor;
  ctx.fillText(label, 16, 24);
  ctx.font = '9px "Consolas", "SF Mono", monospace';
  ctx.fillStyle = '#405060';
  ctx.fillText(`Heavy: ${cfg.HEAVY_DMG}dmg @${Math.round(cfg.HEAVY_HIT*100)}%  Guard: counter ${cfg.GUARD_COUNTER}`, 16, 38);
  ctx.restore();
}

// === DRAW ===
function draw() {
  ctx.clearRect(0, 0, W, H);
  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, `rgb(${cfg.bgTint[0]}, ${cfg.bgTint[1]}, ${cfg.bgTint[2]})`);
  bg.addColorStop(1, '#080a12');
  ctx.fillStyle = bg; ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#0e1020'; ctx.fillRect(0, 290, W, 90);
  ctx.strokeStyle = '#1a1e30'; ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, 290); ctx.lineTo(W, 290); ctx.stroke();

  drawModeIndicator();

  if (gameState === 'title') {
    titlePulse += 0.03;

    // Different title text based on phase
    ctx.textAlign = 'center';

    if (flowPhase === 'a') {
      ctx.font = 'bold 24px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#c0d0e8';
      ctx.fillText('Version A', W/2, 120);
      ctx.font = '14px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#607090';
      ctx.fillText('Fight the CPU. Choose Strike, Heavy, or Guard each turn.', W/2, 148);
      ctx.fillText('Play naturally — try whatever strategy feels right.', W/2, 168);
      const remain = GAMES_REQUIRED - modeStats.before.gamesPlayed;
      if (remain > 0) {
        ctx.font = '12px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#506080';
        ctx.fillText(`${remain} game${remain > 1 ? 's' : ''} to go`, W/2, 198);
      }
    } else if (flowPhase === 'b') {
      ctx.font = 'bold 24px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#80e0a0';
      ctx.fillText('Version B', W/2, 120);
      ctx.font = '14px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#607090';
      ctx.fillText('Same game, same rules. Something is different though.', W/2, 148);
      ctx.fillText('Play the same way and see what happens.', W/2, 168);
      const remain = GAMES_REQUIRED - modeStats.after.gamesPlayed;
      if (remain > 0) {
        ctx.font = '12px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#506080';
        ctx.fillText(`${remain} game${remain > 1 ? 's' : ''} to go`, W/2, 198);
      }
    } else {
      // Free play
      ctx.font = 'bold 22px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#c0d0e8';
      ctx.fillText(cfg.label, W/2, 130);
      ctx.font = '13px "Segoe UI", system-ui, sans-serif'; ctx.fillStyle = '#506080';
      ctx.fillText('Free play — switch versions with [1] and [2]', W/2, 155);
    }

    const st = modeStats[currentMode];
    if (st.gamesPlayed < GAMES_REQUIRED || flowPhase === 'free') {
      const a = 0.5 + Math.sin(titlePulse) * 0.3;
      ctx.globalAlpha = a;
      ctx.font = '14px "Segoe UI", system-ui, sans-serif';
      ctx.fillStyle = cfg.accentColor;
      ctx.fillText('Press SPACE or click FIGHT', W/2, 248);
      ctx.globalAlpha = 1;
    }

    updateStatsDisplay(); return;
  }

  const s = shakeOff();
  ctx.save(); ctx.translate(s.x, s.y);
  drawFighter(pAnim.x, pAnim.y, '#4080c0', player.hp, cfg.MAX_HP, player.guarding, false, pAnim.hf, 'YOU');
  drawFighter(eAnim.x, eAnim.y, '#c04040', enemy.hp, cfg.MAX_HP, enemy.guarding, true, eAnim.hf, 'CPU');
  drawParticles(); drawFloats();
  ctx.restore();

  drawWPChart(305, 20, 180, 55);

  ctx.font = '11px "Segoe UI", system-ui, sans-serif';
  ctx.textAlign = 'center'; ctx.fillStyle = '#304060';
  ctx.fillText(`Turn ${turnCount}`, W/2, H - 6);

  if (gameState === 'gameover') {
    ctx.font = 'bold 30px "Segoe UI", system-ui, sans-serif';
    ctx.textAlign = 'center';
    if (player.hp <= 0 && enemy.hp <= 0) { ctx.fillStyle = '#8090a8'; ctx.fillText('DRAW', W/2, 165); }
    else if (enemy.hp <= 0) { ctx.fillStyle = '#50c070'; ctx.fillText('VICTORY', W/2, 165); }
    else { ctx.fillStyle = '#d06060'; ctx.fillText('DEFEAT', W/2, 165); }
  }
  updateStatsDisplay();
}

function updateStatsDisplay() {
  const st = modeStats[currentMode];
  document.getElementById('sWins').textContent = st.wins;
  document.getElementById('sLosses').textContent = st.losses;
  const total = st.wins + st.losses;
  const wr = total > 0 ? Math.round(st.wins / total * 100) + '%' : '-';
  document.getElementById('sWinRate').textContent = wr;
}

// === COMPARISON BARS (free play) ===
function updateComparisonBars() {
  for (const [mode, prefix] of [['before', 'a'], ['after', 'b']]) {
    const st = modeStats[mode];
    const total = st.wins + st.losses;
    const wr = total > 0 ? st.wins / total * 100 : 0;
    const hr = st.totalActions > 0 ? st.heavyCount / st.totalActions * 100 : 0;

    const wrEl = document.getElementById(`bar-${prefix}-wr`);
    const hrEl = document.getElementById(`bar-${prefix}-hr`);
    const gmEl = document.getElementById(`bar-${prefix}-gm`);
    if (!wrEl) return; // Panel not yet built

    wrEl.style.width = wr + '%';
    document.getElementById(`val-${prefix}-wr`).textContent = total > 0 ? wr.toFixed(0) + '%' : '-';
    hrEl.style.width = hr + '%';
    document.getElementById(`val-${prefix}-hr`).textContent = st.totalActions > 0 ? hr.toFixed(0) + '%' : '-';
    const maxGames = Math.max(
      modeStats.before.wins + modeStats.before.losses,
      modeStats.after.wins + modeStats.after.losses, 1
    );
    gmEl.style.width = (total / maxGames * 100) + '%';
    document.getElementById(`val-${prefix}-gm`).textContent = total;
  }
}

// === MAIN LOOP ===
let lastTime = 0;
function loop(ts) {
  const dt = Math.min(3, (ts - lastTime) / 16.67);
  lastTime = ts;
  if (shakeDur > 0) shakeDur -= dt;
  updateParticles(dt); updateFloats(dt);
  if (pAnim) pAnim.update(dt);
  if (eAnim) eAnim.update(dt);
  draw();
  requestAnimationFrame(loop);
}
updateButtons();
updateBadges();
updatePhaseUI();
requestAnimationFrame(loop);
</script>
</body>
</html>
